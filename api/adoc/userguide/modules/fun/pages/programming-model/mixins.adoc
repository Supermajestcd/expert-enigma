= Mixins

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:page-partial:


A xref:userguide:fun:building-blocks.adoc#mixins[mixin] acts like a trait or extension method, allowing one module to contribute behaviour or derived state to another object.

Syntactically, a mixin is defined using either the xref:refguide:applib-ant:Mixin.adoc[`@Mixin`] annotation or using xref:refguide:applib-ant:DomainObject.adoc#nature[`@DomainObject#nature`] attribute (specifying a nature of `Nature.MIXIN`).

WARNING: TODO: v2: perhaps we should get rid of @DomainObject#nature=MIXIN ?

[source,java]
----
@Mixin(method="coll")                                       // <1>
public class Customer_orders {                              // <2>

    private final Customer customer;
    public Customer_orders(final Customer customer) {       // <3>
        this.customer = customer;
    }

    @Action(semantics=SemanticsOf.SAFE)                     // <4>
    @ActionLayout(contributed=Contributed.AS_ASSOCIATION)   // <4>
    @CollectionLayout(defaultView="table")
    public List<Order> coll() {                             // <1>
        return repositoryService.findOrdersFor(customer);
    }

    @Inject
    RepositoryService repositoryService;
}
----
<1> indicates that this is a mixin, with "coll" as the name of the main method
<2> The contributed member is inferred from the name, after the "_"; in other words "orders"
<3> The mixee is `Customer`.
This could also be an interface.
<4> Indicates that the action should be interpreted as a collection.
This requires that the action has safe semantics, ie does not alter state/no side-effects.

== Contributed Collection

The example below shows how to contribute a collection:

[source,java]
----
@Mixin(method="coll")                                           // <1>
public class DocumentHolder_documents {

    private final DocumentHolder holder;
    public DocumentHolderDocuments(DocumentHolder holder) { this.holder = holder; }

    @Action(semantics=SemanticsOf.SAFE)                         // <2>
    @ActionLayout(contributed = Contributed.AS_ASSOCIATION)     // <3>
    @CollectionLayout(defaultView="table")
    public List<Document> coll() {                              // <4>
        ...
    }
    public boolean hideColl() { /* ... */ }                           // <5>
}
----
<1> indicates this is a mixin, and in this case nominates the method name.
The recommended name for collections is "coll" (if none is specified the default name is "$$").
<2> required; actions that have side-effects cannot be contributed as collections
<3> required; otherwise the mixin will default to being rendered as an action
<4> method (which must match `@Mixin#method` above), must accept no arguments.
The mixin is a collection rather than a property because the return type is a collection, not a scalar.
<5> supporting methods follow the usual naming conventions.
(That said, in the case of collections, because the collection is derived/read-only, the only supporting method that is relevant is `hideColl()`).

The above will result in a contributed collection "documents" for all types that implement/extend from `DocumentHolder`.

== Contributed Property

Contributed properties are defined similarly, for example:

[source,java]
----
@Mixin(method="prop")                                           // <1>
public class DocumentHolder_mostRecentDocument {

    private final DocumentHolder holder;
    public DocumentHolderDocuments(DocumentHolder holder) { this.holder = holder; }

    @Action(semantics=SemanticsOf.SAFE)                         // <2>
    @ActionLayout(contributed = Contributed.AS_ASSOCIATION)     // <3>
    public Document prop() {                                    // <4>
        ...
    }
    public boolean hiderProp() { /* ... */ }                          // <5>
}
----
<1> indicates this is a mixin, and in this case nominates the method name.
The recommended name for properties is "prop" (if none is specified the default name is "$$").
<2> required; actions that have side-effects cannot be contributed as collections
<3> required; otherwise the mixin will default to being rendered as an action
<4> method (which must match `@Mixin#method` above), must accept no arguments.
The mixin is a property rather than a collection because the return type is a scalar.
<5> supporting methods follow the usual naming conventions.
(That said, in the case of properties, because the property is derived/read-only, the only supporting method that is relevant is `hideProp()`).

== Contributed Action

Contributed actions are defined similarly, for example:

[source,java]
----
@Mixin(method="act")                                            // <1>
public class DocumentHolder_addDocument {

    private final DocumentHolder holder;
    public DocumentHolderDocuments(DocumentHolder holder) { this.holder = holder; }

    @Action()
    @ActionLayout(contributed = Contributed.AS_ACTION)          // <2>
    public Document> act(Document doc) {                        // <3>
        ...
    }
    public boolean hideAct() { /* ... */ }                            // <4>
}
----
<1> indicates this is a mixin, and in this case nominates the method name.
The recommended name for properties is "prop" (if none is specified the default name is "$$").
<2> recommended
<3> method must match `@Mixin#method` above.
Unlike contributed properties and collections, contributed actions can accept parameters.
<4> supporting methods follow the usual naming conventions.

== Inferred Name

Where the mixin follows the naming convention `SomeType_mixinName` then the method name can be abbreviated, and the name of the member being contributed is inferred from the name of the class itself, being everything after the last '_'.

For example:

[source,java]
----
@Mixin(method="act")
public class DocumentHolder_documents {

    private final DocumentHolder holder;
    public DocumentHolder_documents(DocumentHolder holder) { this.holder = holder; }

    @Action(semantics=SemanticsOf.SAFE)
    @ActionLayout(contributed = Contributed.AS_ASSOCIATION)
    @CollectionLayout(defaultView="table")
    public List<Document> act() {
        ...
    }
    public boolean hideAct() { /* ... */ }
}
----

The examples above (for xref:userguide:fun:programming-model.adoc#contributed-action[action]) demonstrate this.

The character "$" is also recognized as a separator between the mixin type and mixin name.
This is useful for mixins implemented as nested static types, discussed xref:userguide:fun:programming-model.adoc#nested-static-classes[below].

[[nested-static-classes]]
== As Nested Static Classes

As noted in the introduction, while mixins were originally introduced as a means of allowing contributions from one module to the types of another module, they are also a convenient mechanism for grouping functionality/behaviour against a concrete type.
All the methods and supporting methods end up in a single construct, and the dependency between that functionality and the rest of the object is made more explicit.

When using mixins in this fashion, it is idiomatic to write the mixin as a nested static class, using the naming convention described above to reduce duplication.

For example:

[source,java]
----
public class Customer {

    @Mixin(method="act")
    public static class placeOrder {                                            // <1>

        private final Customer customer;
        public placeOrder(Customer customer) { this.customer = customer; }      // <2>

        @Action
        @ActionLayout(contributed = Contributed.AS_ACTION)
        public List<Order> act(Product p, int quantity) {                        // <3>
            ...
        }
        public boolean hideAct() { /* ... */ }                                         // <4>
        public String validate0Act(Product p) { ...  }
    }
}
----
<1> By convention, start with a lower case, though will also work fine if capitalized.
<2> typically contributed to concrete class, ie the outer class
<3> implementation as usual
<4> supporting methods as usual

== Programmatic usage

When a domain object is rendered, the framework will automatically instantiate all required mixins and delegate to them dynamically.
If writing integration tests or fixtures, or (sometimes) just regular domain logic, then you may need to instantiate mixins directly.

For this you can use the xref:refguide:applib-svc:FactoryService.adoc[`FactoryService#mixin(...)`] method.

For example:

[source,java]
----
DocumentHolder_documents mixin = factoryService.mixin(DocumentHolder_documents.class, customer);
----

