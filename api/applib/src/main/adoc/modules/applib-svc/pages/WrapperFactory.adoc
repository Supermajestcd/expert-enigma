= `WrapperFactory`

:Notice: Licensed to the Apache Software Foundation (ASF) under one or more contributor license agreements. See the NOTICE file distributed with this work for additional information regarding copyright ownership. The ASF licenses this file to you under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at. http://www.apache.org/licenses/LICENSE-2.0 . Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR  CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.
:page-partial:

WARNING: Document `WrappingObject`, document `AsyncControl`


The `WrapperFactory` provides the ability to enforce business rules for programmatic interactions between domain objects.
If there is a (lack-of-) trust boundary between the caller and callee -- eg if they reside in different modules -- then the wrapper factory is a useful mechanism to ensure that any business constraints defined by the callee are honoured.

For example, if the calling object attempts to modify an unmodifiable property on the target object, then an exception will be thrown.
Said another way: interactions are performed "as if" they are through the viewer.

[NOTE]
====
For a discussion of the use of the `WrapperFactory` within integration tests (the primary or at least original use case for this service) can be found xref:testing:integtestsupport:about.adoc#wrapper-factory[here]
====

This capability goes beyond enforcing the (imperative) constraints within the `hideXxx()`, `disableXxx()` and `validateXxx()` supporting methods; it also enforces (declarative) constraints such as those represented by annotations, eg `@Parameter(maxLength=...)` or `@Property(mustSatisfy=...)`.

This capability is frequently used within xref:testing:integtestsupport:about.adoc[integration tests], but can also be used in production code.

== API

The API breaks into three.

=== Main API

The main API provided by the service is:

[source,java]
----
include::refguide:applib-svc:example$services/wrapper/WrapperFactory.java[tags="refguide"]
----
<.> wraps the underlying domain object with a wrapper configured with the set of ``ExecutionMode``s.
+
If the domain object is already wrapped, then wrapping it again does nothing; the wrapper is returned unchanged.
+
The `ExecutionMode` modifies the way in which the wrapper interacts with the underlying domain object:
+
[source,java]
----
include::refguide:applib-svc:example$services/wrapper/WrapperFactory.java[tags="refguide-1",indent=0]
----
+
As a convenience, the `ExecutionModes` class defines some predefined sets of the `ExecutionMode` enum:
+
[source,java]
----
include::refguide:applib-svc:example$services/wrapper/WrapperFactory.java[tags="refguide-2",indent=0]
----

<.> wraps the underlying domain object with a wrapper that will validate all business rules and then execute if they pass.
+
This is the same as invoke `wrap(...)` with `ExecutionModes.EXECUTE`.

<.> wraps the underlying domain object with a wrapper that will validate all business rules and then execute if they pass, but will simply skip execution if any of the business rules fail (returning null).
+
This is the same as invoke `wrap(...)` with `ExecutionModes.TRY`.

<.> wraps the underlying domain object with a wrapper that will validate all business rules but will not actually perform the interaction.
+
This is the same as invoke `wrap(...)` with `ExecuteModes#NO_EXECUTE`.

<.> wraps the underlying domain object with a wrapper that will NOT check any business rules and instead will just perform the interaction.
+
This is the same as invoke `wrap(...)` with `ExecuteMode#SKIP_RULES`.

<.> instantiates and wraps a mixin, with no modifiers to the execution.

<.> Obtains the underlying domain object, if wrapped.
+
If the object is not wrapped, returns back unchanged.

<.> whether the supplied object has been wrapped.


The service works by returning a "wrapper" around a supplied domain object (using link:https://bytebuddy.net/[byte buddy]), and it is this wrapper that ensures that the hide/disable/validate rules implies by the Apache Isis programming model are enforced.
The wrapper can be interacted with as follows:

* a `get...()` method for properties or collections
* a `set...()` method for properties
* an `addTo...()` or `removeFrom...()` method for collections
* any action

Calling any of the above methods may result in a (subclass of) `InteractionException` if the object disallows it.
For example, if a property is annotated with `@Hidden` then a `HiddenException` will be thrown.
Similarly if an action has a `validateXxx()` method and the supplied arguments are invalid then an `InvalidException` will be thrown.

In addition, the following methods may also be called:

* the xref:refguide:applib-cm:methods.adoc#title[`title()`] and `toString()` methods
* any xref:refguide:applib-cm:methods.adoc#default[`default...()`], xref:refguide:applib-cm:methods.adoc#choices[`choices...()`] or xref:refguide:applib-cm:methods.adoc#autoComplete[`autoComplete...()`] methods

An exception will be thrown if any other methods are thrown.

If the interface is performed (action invoked or property set), then - irrespective of whether the business rules were checked or skipped - a xref:refguide:applib-ant:Action.adoc#command[command] will be created and pre- and post-execute xref:refguide:applib-ant:Action.adoc#domainEvent[domain event]s) will be fired.



=== `AsyncWrap` API

The `WrapperFactory` also allows domain objects to be interacted with in an asynchronous fashion:

[source,java]
----
include::refguide:applib-svc:example$services/wrapper/WrapperFactory.java[tags="refguide-async"]
----
<.> x
<.> x
<.> x
<.> x

WARNING: TODO: there are some caveats to using this approach.


=== Listener API

[source,java]
----
include::refguide:applib-svc:example$services/wrapper/WrapperFactory.java[tags="refguide-listeners"]
----


== Usage

The caller will typically obtain the target object (eg from some repository) and then use the injected `WrapperFactory` to wrap it before interacting with it.

For example:

[source,java]
----
public class CustomerAgent {
    @Action
    public void refundOrder(final Order order) {
        final Order wrappedOrder = wrapperFactory.wrap(order);
        try {
            wrappedOrder.refund();
        } catch(InteractionException ex) {          // <1>
            messageService.raiseError(ex.getMessage());  // <2>
            return;
        }
    }
    ...
    @Inject
    WrapperFactory wrapperFactory;
    @Inject
    MessageService messageService;
}
----
<1> if any constraints on the `Order`'s `refund()` action would be violated, then ...
<2> ... these will be trapped and raised to the user as a warning.

[NOTE]
====
It ought to be possible to implement an xref:refguide:applib-svc:ExceptionRecognizerService.adoc[`ExceptionRecognizer`]s that would allow the above boilerplate to be removed.
This recognizer service would recognize the `InteractionException` and convert to a suitable message.

At the time of writing Apache Isis does not provide an out-of-the-box implementation of such an `ExceptionRecognizer`; but it should be simple enough to write oneâ€¦
====

== Listener API

The `WrapperFactory` also provides a listener API to allow other services to listen in on interactions.

[source,java]
----
public interface WrapperFactory {
    ...
    @Programmatic
    List<InteractionListener> getListeners();                               // <1>
    @Programmatic
    public boolean addInteractionListener(InteractionListener listener);    // <2>
    @Programmatic
    public boolean removeInteractionListener(InteractionListener listener); // <3>
    @Programmatic
    public void notifyListeners(InteractionEvent ev);                       // <4>
}
----
<1> all ``InteractionListener``s that have been registered.
<2> registers an `InteractionListener`, to be notified of interactions on all wrappers.
The listener will be notified of interactions even on wrappers created before the listener was installed.
(From an implementation perspective this is because the wrappers delegate back to the container to fire the events).
<3> remove an `InteractionListener`, to no longer be notified of interactions on wrappers.
<4> used by the framework itself


One possible use case for this API is to enable test transcripts to be captured (in a BDD-like fashion) from integration tests.
As the time of writing, no such feature has yet been implemented.



