<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
"file:./src/docbkx/dtd-4.5/docbookx.dtd">
<!--
  Licensed to the Apache Software Foundation (ASF) under one
  or more contributor license agreements.  See the NOTICE file
  distributed with this work for additional information
  regarding copyright ownership.  The ASF licenses this file
  to you under the Apache License, Version 2.0 (the
  "License"); you may not use this file except in compliance
  with the License.  You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing,
  software distributed under the License is distributed on an
  "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, either express or implied.  See the License for the
  specific language governing permissions and limitations
  under the License.
-->
<book>
  <bookinfo>
    <title><?eval ${docbkxGuideTitle}?></title>

    <subtitle><?eval ${docbkxGuideSubTitle}?></subtitle>

    <releaseinfo><?eval ${project.version}?></releaseinfo>

    <authorgroup>
      <author>
        <firstname>Dan</firstname>

        <surname>Haywood</surname>
      </author>

      <author>
        <firstname>Robert</firstname>

        <surname>Matthews</surname>
      </author>
    </authorgroup>

    <legalnotice>
      <para>Permission is granted to make and distribute verbatim copies of
      this manual provided that the copyright notice and this permission
      notice are preserved on all copies.</para>
    </legalnotice>
  </bookinfo>

  <!-- front matter -->

  <toc></toc>

  <preface id="preface">
    <title>Preface</title>

    <para><emphasis>Apache Isis</emphasis> is designed to allow programmers
    rapidly develop domain-driven applications following the <ulink
    url="http://en.wikipedia.org/wiki/Naked_Objects">Naked Objects</ulink>
    pattern. It is made up of a core plus a number of components for each of
    the main APIs: objectstores, security, viewers and profilestores.</para>

    <para>This guide is written for programmers looking to understand the
    programming conventions, annotations and supporting utilities within the
    <emphasis>Apache Isis</emphasis> application library (or
    <emphasis>applib</emphasis>), in order that the framework can correctly
    pick up and render the business rules and logic encoded within their
    domain objects.</para>

    <para><emphasis>Apache Isis</emphasis> is hosted at the <ulink
    url="http://incubator.apache.org/isis">Apache Foundation</ulink>, and is
    licensed under <ulink
    url="http://www.apache.org/licenses/LICENSE-2.0.html">Apache Software
    License v2</ulink>.</para>
  </preface>

  <!-- main content -->

  <part id="prt.WritingDomainObjects">
    <title>Writing Domain Objects</title>

    <partintro>
      <para>The conventions of the programming model are best described as
      'intentional' - they convey an intention as to how domain objects, their
      properties and behaviours, are to be made available to users. The
      specific way in which those intentions are interpreted or implemented
      will depend upon the framework, and/or the particular components or
      options selected within that framework.</para>

      <para>To pick a single example, marking up a domain class with the
      annotation <code>@Bounded</code> is an indication that the class is
      intended to have only a small number of instances and that the set does
      not change very often - such as the class <code>Country</code>. This is
      an indication to a viewer, for example, that the whole set of instances
      might be offered to the user in a convenient form such as a drop-down
      list. The programming convention has <emphasis>not</emphasis> been
      defined as <code>@DropDownList</code> because any equivalent mechanism
      will suffice: a viewer might not support drop-down-lists but instead
      might provide a capability to select from an <code>@Bounded</code> class
      by typing the initial letters of the desired instance.</para>

      <para>This part of the guide is a set of chapters that provides how-to's
      for writing domain objects, by which we mean domain entities, value
      types, services and repositories/factories.</para>
    </partintro>

    <chapter id="chp.Objects">
      <title>How to write a basic Domain Entity or Service</title>

      <abstract>
        <para>How-to write a basic domain entity or service, specifying its
        properties, collections and actions, and using some of the most
        commonly-used additional semantics.</para>
      </abstract>

      <para>Domain entities are instances of some class, usually (the vast
      majority) being persisted. Domain services are singletons that act
      typically act as factories and repositories. Domain entities have state
      in the form of properties and collections; domain services do not. Both
      domain entities and services have behaviour, in the form of
      actions.</para>

      <sect1>
        <title>How to have a domain entity be a POJO (not inherit from
        framework superclasses)</title>

        <para>It isn't mandatory for domain entities to inherit from any
        framework superclass; they can be plain old java objects (pojos) if
        required. However, they do at a minimum need to have a
        <classname>org.apache.isis.applib.DomainObjectContainer</classname>
        injected into them (an interface), from which other framework services
        can be accessed.</para>

        <para>If you don't have a requirement to inherit from any other
        superclass, then it usually makes sense to inherit from mention
        <classname>org.apache.isis.applib.AbstractDomainObject</classname>,
        which already supports the
        <classname>DomainObjectContainer</classname> and has a number of
        convenience helper methods.</para>

        <para>There is further coverage of
        <classname>DomainObjectContainer</classname> in <xref
        linkend="sec.LifecycleMethods" /> and also in <xref
        linkend="chp.DomainServices" />.</para>
      </sect1>

      <sect1 id="sec.AbstractService">
        <title>How to have a domain service be a POJO (not inherit from
        framework superclasses)</title>

        <para>Like entities, it isn't mandatory for domain services to inherit
        from any framework superclass; they can be plain-old pojos if
        required. However, again, like entities, they do at a minimum need to
        have a
        <classname>org.apache.isis.applib.DomainObjectContainer</classname>
        injected into them (an interface), from which other framework services
        can be accessed.</para>

        <para>If you don't have a requirement to inherit from any other
        superclass, then it usually makes sense to inherit from one of the
        abstract classes in the applib, either
        <classname>org.apache.isis.applib.AbstractService</classname> or
        <classname>org.apache.isis.applib.AbstractRepositoryAndFactory</classname>.
        These already supports the
        <classname>DomainObjectContainer</classname> and have a number of
        convenience helper methods.</para>

        <para>The <acronym>UML</acronym> class diagram below shows the
        relationship between these types and the
        <classname>DomainObjectContainer</classname>.</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/AbstractContainedObject-hierarchy.png"
                       scale="65" />
          </imageobject>
        </mediaobject>

        <para>What this means is that <emphasis>Apache Isis</emphasis> treats
        factories and repositories as just another type of domain
        service.</para>
      </sect1>

      <sect1>
        <title>How to add a property to a domain entity</title>

        <para>A property is a scalar attribute or field of a domain entity.
        Its type can be either a value type (such as an int, Date or String),
        or a reference to another entity.</para>

        <para>Properties are specified using the JavaBean conventions,
        recognizing a standard accessor/mutator pair (<code>get</code> and
        <code>set</code>).</para>

        <para>The syntax is:</para>

        <para><programlisting>public PropertyType getPropertyName() 

public void setPropertyName(PropertyType param)</programlisting></para>

        <para>where <literal moreinfo="none">PropertyType</literal> is a
        primitive, a value object or an entity object.</para>

        <para>Properties may either be for a value type or may reference
        another entity. Values include Java primitives, and JDK classes with
        value semantics (eg <literal
        moreinfo="none">java.lang.Strings</literal> and <literal
        moreinfo="none">java.util.Dates</literal>; see <xref
        linkend="chp.ValueTypes" /> for the full list). It is also possible to
        write your own value types (see <xref linkend="chp.ValueTypes" />). A
        property referencing another domain object is sometimes called an
        association.</para>

        <para>For example, the following example contains both a value
        (<literal moreinfo="none">String</literal>) property and a reference
        (<literal moreinfo="none">Organisation</literal>) property:</para>

        <programlisting format="linespecific">public class Customer {

    private String firstName;
    public String getFirstName() {
        return firstName;
    }
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }


    private Organisation organisation;
    public Organisation getOrganisation() {
        return organisation;
    }
    public void setOrganisation(Organisation organisation) { 
        this.organisation = organisation;
    }

    ...
}</programlisting>
      </sect1>

      <sect1>
        <title condition="java">How to specify a title for a domain
        entity</title>

        <para>A title is used to identify an object to the user in the user
        interface. For example, a <classname>Customer</classname>'s title
        might be the organization's customer reference, or perhaps (more
        informally) their first and last names.</para>

        <para>By default, the framework will use the object's <literal
        moreinfo="none">toString()</literal> method as the title. Most titles
        tend to be made up of the same set of elements: for example a
        Customer's name might be the concatenation of their customer first
        name and their ;ast name. For these the <classname>@Title</classname>
        annotation can be used:</para>

        <para><programlisting>public class Customer {
  @Title
  public String getFirstName() { ... }
  @Title
  public String getLastName() { ... }
  ...
}</programlisting></para>

        <para>For more control, the order of the title components can be
        specified using a sequence number (specified in Dewey decimal
        format):</para>

        <programlisting>public class Customer {
  @Title("1.0")
  public String getFirstName() { ... }
  @Title("1.1")
  public String getLastName() { ... }
  ...
}</programlisting>

        <para>For more control the title can be declared imperately using the
        <literal moreinfo="none">title()</literal> method (returning a
        <literal moreinfo="none">String</literal>). This leaves the programmer
        needs to make use of the <literal moreinfo="none">toString()</literal>
        method for other purposes, such as for debugging. For example, to
        return the title for a customer which is their last name and then
        first initial of their first name, we could use:</para>

        <para><programlisting>public class Customer {
  public String title() {
    return getLastName() + ", " + getFirstName().substring(0,1);
  } 
  ...
}</programlisting></para>

        <para>The applib contains a class,
        <classname>org.apache.isis.applib.util.TitleBuffer</classname>, which
        you can use to help create title strings if you so wish. See <xref
        linkend="apx.UtilityClasses" /> for more details.</para>
      </sect1>

      <sect1>
        <title>How to add a collection to a domain entity</title>

        <para>A collection is a multi-valued attribute/field of a entity, in
        other words a <code>List</code> or a <code>Set</code>, containing
        references to other domain entities. <code>Map</code>s are not
        supported. Collections of value types are not supported.</para>

        <para>A collection is recognized via an accessor/mutator method pair
        (<code>get</code> and set) for any type of collection provided by the
        programming language.</para>

        <para>The syntax is either:</para>

        <para><programlisting>public Collection&lt;EntityType&gt; getCollectionName()
private void setCollectionName(Collection&lt;EntityType&gt; param)</programlisting></para>

        <para>or:</para>

        <para><programlisting>public List&lt;EntityType&gt; getCollectionName()
private void setCollectionName(List&lt;EntityType&gt; param)</programlisting></para>

        <para>or:</para>

        <para><programlisting>public Set&lt;EntityType&gt; getCollectionName()
private void setCollectionName(Set&lt;EntityType&gt; param)</programlisting></para>

        <para>A mutator is required, but it need only have
        <code>private</code> visibility.</para>

        <para>Note:</para>

        <note>
          <para><classname>Map</classname>s cannot be used for
          collections.</para>
        </note>

        <para>It is recommended that the collections be specified using
        generics (for example: <literal
        moreinfo="none">List&lt;Customer&gt;</literal> ). That way the
        framework will be able to display the collection based on that type
        definition. If a raw type is used then the framework will attempt to
        infer the type from the addToXxx() / removeFromXxx() supporting
        methods, if specified (see <xref linkend="sec.AddToRemoveFrom" />). If
        the framework is unable to determine the type of the collection, it
        will mean that some viewers will represent the collection is a less
        sophisticated manner (eg a simple list of titles rather than a
        table).</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Employee { ... }

public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List &lt;Employee&gt; getEmployees() {
        return employees;
    }
    private void setEmployees(List&lt;Employee&gt; employees) { 
        this.employees = employees;
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to add an action (or bulk action) to a domain entity or
        service</title>

        <para>An 'action' is a method that we expect the user to be able to
        invoke on a domain entity via the user interface, though it may also
        be invoked programmatically within the object model. The following
        conventions are used to determine when and how methods are made
        available to the user as actions, and the means by which a user can
        interact with those actions</para>

        <para>By default, any <literal moreinfo="none">public</literal>
        instance method that you add to a class will be treated as a user
        action, unless it represents a property, collection, or another
        reserved method defined in this guide.</para>

        <para>The syntax is:</para>

        <para><programlisting>public void actionName([ValueOrEntityType param] ...)</programlisting></para>

        <para>or</para>

        <para><programlisting>public ReturnType actionName([ValueOrEntityType param] ...)</programlisting></para>

        <para>When a method returns a reference the viewer will attempt to
        display that object. If the return value is <code>null</code> then
        nothing is displayed.</para>

        <para>We refer to all methods that are intended to be invoked by users
        as 'action methods'.</para>

        <para>If you have a method that you don't want to be made available as
        a user-action you can either:</para>

        <itemizedlist>
          <listitem>
            <para>make it non-<literal>public</literal> (eg <literal
            moreinfo="none">protected</literal> or <literal
            moreinfo="none">private</literal>)</para>
          </listitem>

          <listitem>
            <para>annotate it with <classname>@Ignore</classname></para>
          </listitem>

          <listitem>
            <para>annotate it with <classname>@Hidden</classname> (discussed
            further in <xref linkend="sec.HiddenActions" />)</para>
          </listitem>
        </itemizedlist>

        <para>Note also that <literal moreinfo="none">static</literal> methods
        are ignored: such functionality should reside in a service, such as a
        repository or factory (see <xref
        linkend="chp.DomainServices" />).</para>

        <para>If the action is a bulk action - meaning that it should only be
        applied to a collection of instances of the entity - then annotate
        using <classname>@Bulk</classname>:</para>

        <programlisting>@Bulk
public void actionName() { ... }</programlisting>

        <para>Note that bulk actions have a couple of important
        restrictions.</para>

        <itemizedlist>
          <listitem>
            <para>entity actions cannot take any arguments, while contributed
            actions can take only a single parameter (the contributee)</para>

            <para>This restriction might be lifted in the future;</para>
          </listitem>

          <listitem>
            <para>any business rules for hiding, disabling or validating the
            action are ignored.</para>
          </listitem>
        </itemizedlist>

        <para>See <xref linkend="chp.BusinessRules" /> for more details on
        writing business rules.</para>

        <para>At the time of writing, only the Wicket viewer recognizes bulk
        actions; other viewers treat the action as a regular action.</para>
      </sect1>

      <sect1 id="sec.HowToSpecifyTheIconForAnObjectsClass">
        <title condition=".net">How to specify the icon for a domain
        entity</title>

        <para condition="1.5">By default, the framework will look for an image
        in the <filename class="directory" moreinfo="none">images</filename>
        directory (either from the classpath or from the filesystem) that has
        the same name as the object class. Multiple file extensions are
        searched for, including <filename>.png</filename>,
        <filename>.gif</filename> and <filename>.jpg</filename> (in order of
        preference). For example, fan object of type
        <classname>Customer</classname> it will look for <filename
        class="directory" moreinfo="none">Customer.png</filename>, <filename
        class="directory" moreinfo="none">Customer.gif</filename>,
        <filename>Customer.jpg</filename> etc.</para>

        <para condition="1.5">If the framework finds no such file, then it
        will work up the inheritance hierarchy to see if there is an icon
        matching the name of any of the super-classes, and use that instead.
        If no matching icon is found then the framework will look for an image
        called <filename class="directory"
        moreinfo="none">default.png</filename>,
        <filename>default.gif</filename> or <filename>default.jpg</filename>
        in the images directory, and if this has not been specified, then the
        framework will use its own default image for an icon.</para>

        <para>We strongly recommend that you adopt 'pascal case' as the
        convention for icon file names: if you have a class called <classname
        condition="vb"> OrderLine</classname>, then call the icon <filename
        class="directory" moreinfo="none">OrderLine.png</filename>. Actually,
        the framework will also recognise <filename class="directory"
        moreinfo="none">orderline.png</filename>, but some operating systems
        and deployment environments are case sensitive, so it is good practice
        to adopt an unambiguous convention.</para>

        <para>Alternatively, you can use the <literal
        moreinfo="none">iconName</literal>() method instead:</para>

        <programlisting format="linespecific">public String iconName() {
    return "Person";
}</programlisting>

        <para>This makes it easy for more than one class to use the same icon,
        without having to duplicate the image file.</para>
      </sect1>

      <sect1 id="sec.MemberOrderForProperties">
        <title>How to specify the order in which properties or collections are
        displayed</title>

        <para>The <literal moreinfo="none">@MemberOrder</literal> annotation
        provides a hint to the viewer as to the order in which the properties
        and collections should appear in the <acronym>GUI</acronym>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer() {
    @MemberOrder("1")
    public String getFirstName() { ... }
    ...

    @MemberOrder("2")
    public String getLastName() { ... }
    ...

    @MemberOrder("3")
    public Collection&lt;Order&gt; getOrders() { ... }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to specify the order in which actions appear on the
        menu</title>

        <para>The <literal moreinfo="none">@MemberOrder</literal> annotation
        provides a hint to the viewer as to the order in which the actions
        should be displayed, eg in a menu.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    @MemberOrder("3")
    public void placeOrder(Product p) { ... }
    ...

    @MemberOrder("4")
    public void blackList() { ... }
    ...
}</programlisting>

        <para>The syntax for the <classname>@MemberOrder</classname> is dewey
        decimal notation, so "3.5" and "3.6" come between "3" and "4"; "3.5.1"
        comes between "3.5" and "3.6".</para>
      </sect1>

      <sect1>
        <title>How to make a property optional (when saving an object)</title>

        <para>By default, when a new transient (unsaved) object is presented
        to the user, values must be specified for all properties before the
        object may be saved.</para>

        <para>To specify that a particular property is optional, use the
        <literal moreinfo="none">@Optional</literal> annotation.</para>
      </sect1>

      <sect1>
        <title>How to make an action parameter optional</title>

        <para>By default, the framework assumes that when an action method is
        to be invoked, all the parameters are mandatory. You may override this
        behaviour by marking up one or more of the paramaters with the
        <literal moreinfo="none">@Optional</literal> annotation.</para>
      </sect1>

      <sect1 id="sec.SizeProperties">
        <title>How to specify the size of <classname>String</classname>
        properties</title>

        <para>Use:</para>

        <itemizedlist>
          <listitem>
            <para>the <literal moreinfo="none">@MaxLength</literal> to specify
            the maximum number of characters that may be stored within a
            <classname>String</classname> property.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@TypicalLength</literal> to
            specify the typical number of characters that are likely to be
            stored within a <classname>String</classname> property. Viewers
            are expected to use this as a hint as to the size of the field to
            render for the property.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@MultiLine</literal> annotation
            as a hint to indicate that the property should be displayed over
            multiple lines (eg as a text area rather than a text
            field).</para>
          </listitem>
        </itemizedlist>

        <para>For example:</para>

        <programlisting format="linespecific">public class Ticket {
    @TypicalLength(50)
    @MaxLength(255)
    public String getDescription() { ... }
    ...

    @MaxLength(2048)
    @MultiLine
    public String getNotes() { ... }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to specify the size of <classname>String</classname> action
        parameters</title>

        <para>As for properties (see <xref linkend="sec.SizeProperties" />),
        use:</para>

        <itemizedlist>
          <listitem>
            <para>the <literal moreinfo="none">@MaxLength</literal> to specify
            the maximum number of characters that may be stored within a
            <classname>String</classname> parameter.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@TypicalLength</literal> to
            specify the typical number of characters that are likely to be
            stored within a <classname>String</classname> parameter. Viewers
            are expected to use this as a hint as to the size of the field to
            render for the parameter.</para>
          </listitem>

          <listitem>
            <para>the <literal moreinfo="none">@MultiLine</literal> annotation
            as a hint to indicate that the parameter should be displayed over
            multiple lines (eg as a text area rather than a text
            field).</para>
          </listitem>
        </itemizedlist>

        <para>For example:</para>

        <programlisting format="linespecific">public class TicketRaiser {

    public void raiseTicket(
            @TypicalLength(50) @MaxLength(255) @Named("Description")
            String getDescription,
            @MaxLength(2048) @MultiLine @Named("Notes")
            String notes) {
        ...
    }
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.ActionParameterNames">
        <title>How to specify names and/or descriptions for an action
        parameter</title>

        <para>Unlike with properties, the framework cannot pick up the names
        of parameters that you use within the domain code. By default
        parameters will be labelled only with the type of the object required
        (e.g. 'String:' or 'Customer:)</para>

        <para>If you want a parameter to have a different name (such as 'First
        Name', 'Last Name') then that parameter should be marked up with an
        <literal moreinfo="none">@Named</literal> annotation - very often
        taking the same form as the parameter name used in the code.
        Alternatively though, you could create a user-defined value type,
        using <literal>@Value</literal> (see <xref
        linkend="chp.ValueTypes" />).</para>

        <para>Similarly, any parameter may be given a short user-description
        using the <literal moreinfo="none">@DescribedAs</literal> annotation.
        The framework takes responsibility to make this available to the
        user.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
            Product p, 
            @Named("Quantity")
            @DescribedAs("The number of units of the specified product in this order")
            int quantity) {
        ...
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to inject services into a domain entity or other
        service</title>

        <para>All that is required to inject a service into an entity (or
        indeed into another service) is to provide an appropriately typed
        setter. The name of the method does not matter, only that it is
        prefixed "set", is public, and has a single parameter of the correct
        type.</para>

        <para>For example:</para>

        <programlisting>public class Customer {
    private OrderRepository orderRepository;
    public void setOrderRepository(OrderRepository orderRepository) {
        this.orderRepository = orderRepository;
    }
    ...
}</programlisting>

        <para>Note that we consider
        <classname>DomainObjectContainer</classname> to be a service too;
        hence it can be injected in exactly the same manner.</para>
      </sect1>

      <sect1 id="sec.HowToCreateAnObject">
        <title>How to create or delete objects within your code</title>

        <para>When you create any domain object within your application code,
        it is important that the framework is made aware of the existence of
        this new object - in order that it may be persisted to the object
        store, and in order that any services that the new object needs are
        injected into it.</para>

        <para>Just specifying <literal moreinfo="none">new
        Customer()</literal>, for example, will create a
        <classname>Customer</classname> object, but that object will
        <emphasis>not</emphasis> be known to the framework. However, since we
        do not want to tie our domain objects to a particular framework, we
        use the idea of a 'container' to mediate, specified by the <literal
        moreinfo="none">org.apache.isis.applib.DomainObjectContainer</literal>
        interface. See <xref linkend="apx.DomainObjectContainer" /> for the
        full list of methods provided by
        <classname>DomainObjectContainer</classname>.</para>

        <para>This interface defines the following methods for managing domain
        objects:</para>

        <itemizedlist>
          <listitem>
            <para><literal moreinfo="none">&lt;T&gt; T
            newTransientInstance(final Class&lt;T&gt;
            ofClass)</literal></para>

            <para>Returns a new instance of the specified class, that is
            transient (unsaved). The object may subsequently be saved either
            by the user invoking the Save action (that will automatically be
            rendered on the object view) or programmatically by calling
            <literal moreinfo="none">persist(Object
            transientObject)</literal></para>
          </listitem>

          <listitem>
            <para><methodname>&lt;T&gt; T newPersistentInstance(final
            Class&lt;T&gt; ofClass)</methodname></para>

            <para>Creates a new object already persisted.</para>
          </listitem>

          <listitem>
            <para><methodname>boolean isPersistent()</methodname></para>

            <para>Checks whether an object has already been persisted. This is
            often useful in controlling visibility or availability of
            properties or actions.</para>
          </listitem>

          <listitem>
            <para><methodname>void persist(Object
            transientObject)</methodname></para>

            <para>Persists a transient object (created using
            <methodname>newTransientInstance(...)</methodname>, see
            above).</para>
          </listitem>

          <listitem>
            <para><methodname>void persistIfNotAlready(Object
            domainObject)</methodname></para>

            <para>It is an error to persist an object if it is already
            persistent; this method will persist only if the object is not
            already persistent (otherwise it will do nothing).</para>
          </listitem>

          <listitem>
            <para><methodname>void remove(Object
            persistentObject)</methodname></para>

            <para>Removes (deletes) from the object store, making the
            reference transient.</para>
          </listitem>

          <listitem>
            <para><methodname>void removeIfNotAlready(Object
            domainObject)</methodname></para>

            <para>It is an error to remove an object if it is not persistent;
            this method will remove only if the object is known to be
            persistent (otherwise it will do nothing).</para>
          </listitem>
        </itemizedlist>

        <para>A domain object specifies that it needs to have a reference to
        the <classname>DomainObjectContainer</classname> injected into by
        including the following code:</para>

        <programlisting format="linespecific">private DomainObjectContainer container;
protected DomainObjectContainer getContainer() {
    return container;
}
public final void setContainer(final DomainObjectContainer container) {
    this.container = container;
}</programlisting>

        <para>Creating or deleting objects is then done by invoking those
        methods on the container. For example the following code would then
        create a new <classname>Customer</classname> object within another
        method:</para>

        <programlisting format="linespecific">Customer newCust = getContainer().newTransientInstance(Customer.class);
newCust.setName("Charlie");
getContainer().persist(newCust);</programlisting>

        <para>If you are able to make your domain object inherit from <literal
        moreinfo="none">org.apache.isis.applib.AbstractDomainObject</literal>
        then you have direct access to those methods, so the code would
        become:</para>

        <programlisting format="linespecific">Customer newCust = newTransientInstance(Customer.class);
newCust.setName("Charlie");
persist(newCust);</programlisting>

        <para>As an alternative to putting the creation logic within your
        domain objects, you could alternatively delegate to an injected
        factory (see <xref linkend="chp.DomainServices" />). Ultimately
        factories just delegate back to
        <classname>DomainObjectContainer</classname> in the same way, so from
        a technical standpoint there is little difference. However it is
        generally worth introducing a factory because it provides a place to
        centralize any business logic. It also affords the opportunity to
        introduce a domain term (eg <classname>ProductCatalog</classname> or
        <classname>StudentRegister</classname>), thereby reinforcing the
        "ubiquitous language".</para>

        <para>These methods are actually provided by the
        <classname>org.apache.isis.applib.AbstractContainedObject</classname>
        and so are also available on <literal
        moreinfo="none">org.apache.isis.applib.AbstractService</literal> (and,
        hence, on <literal
        moreinfo="none">org.apache.isis.applib.AbstractFactoryAndRepository</literal>)
        for creating objects within a service.</para>

        <warning>
          <para>It is possible to create a transient object within another
          transient object. When the framework persists any transient object,
          by default it will automatically persist any other transient object
          referenced by that object. However, if any of these transient
          objects are to be exposed to the user (while in their transient
          state), then you need to write your code very carefully -
          anticipating the fact that the user could elect to save any of the
          transient objects at any point - which could cause the graph of
          related objects to be persisted in an invalid state.</para>

          <para>The recommended approach is, if possible, to mark these
          supplementary classes as not persistable by the user (see <xref
          linkend="not-persistable" />), or not to permit the user to create a
          new transient object that is a child of an existing transient
          object, but, rather, to require the user to save the parent object
          first.</para>
        </warning>
      </sect1>
    </chapter>

    <chapter id="chp.BusinessRules">
      <title>How to add business rules</title>

      <abstract>
        <para>How-to add business rules to domain entities and services,
        controlling whether a domain entity or service's class members are
        visible, if they are enabled, and to validate arguments.</para>
      </abstract>

      <para>Business rules can be added to domain objects in a number of ways.
      As well as the business logic encapsulated by domain object actions, the
      framework also supports a number of conventions that allow a domain
      entity or service's members to be made visible or hidden, to be enabled
      or disabled (greyed out), and to validate arguments when invoking an
      action, setting a new value for a property, or if adding a new element
      to a collection.</para>

      <para>Or, in other words: "see it, use it, do it".</para>

      <sect1 id="sec.HiddenProperty">
        <title>How to hide a property</title>

        <para>The mechanism for hiding a property is broadly the same as for
        hiding a collection (see <xref linkend="sec.HiddenCollection" />) or
        an action (see <xref linkend="sec.HiddenActions" />).</para>

        <para>For control over the entire object, see <xref
        linkend="sec.Entity.Hidden" />.</para>

        <sect2>
          <title>Hiding a property always</title>

          <para>To prevent a user from viewing a property at all, use the
          <literal moreinfo="none">@Hidden</literal> annotation. A common use
          case is to hide an internal Id, eg perhaps as required by the object
          store.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class OrderLine {
    private Integer id;
    @Hidden
    public Integer getId() { ... }
    public void setId(Integer id) { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a property based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a property may be optionally
          hidden using the <classname>@Hidden</classname> annotation based on
          the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to hide the property when the object is transient, use
              <code>@Hidden(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to hide the property when the object is persistent, use
              <code>@Hidden(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Hiding a property under certain conditions</title>

          <para>A <literal moreinfo="none">hideXxx()</literal> method can be
          used to indicate that a particular object's property should be
          hidden under certain conditions, typically relating to the state of
          that instance.</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public boolean hidePropertyName()</literal> </programlisting>

          <para>Returning a value of <code>true</code> indicates that the
          property should be hidden.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public String getShippingInstructions() { ... }
    public void setShippingInstructions(String shippingInstructions) { ... }
    public boolean hideShippingInstructions() {
        return hasShipped();
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a property for specific users or roles</title>

          <para>It is possible to hide properties for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" />for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.HiddenCollection">
        <title>How to hide a collection</title>

        <para>The mechanism for hiding a collection is broadly the same as for
        hiding a property (see <xref linkend="sec.HiddenProperty" />) or an
        action (see <xref linkend="sec.HiddenActions" />).</para>

        <sect2>
          <title>Hiding a collection permanently</title>

          <para>To prevent a user from viewing a collection at all, use the
          <literal moreinfo="none">@Hidden</literal> annotation.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    private List&lt;Order&gt; cancelledOrders = new ArrayList&lt;Order&gt;();
    @Hidden
    public List&lt;Order&gt; getCancelledOrders() { ... }
    private void setCancelledOrders(List&lt;Order&gt; cancelledOrders) { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a collection based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a collection may be optionally
          hidden using the <classname>@Hidden</classname> annotation based on
          the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to hide the collection when the object is transient, use
              <code>@Hidden(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to hide the collection when the object is persistent, use
              <code>@Hidden(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Hiding a collection under certain conditions</title>

          <para>A <literal moreinfo="none">hideXxx()</literal> method can be
          used to indicate that a particular object's collection should be
          hidden under certain conditions, typically relating to the state of
          that instance.</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public boolean hideCollectionName()</literal> </programlisting>

          <para>Returning a value of <code>true</code> indicates that the
          collection should be hidden.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    @Hidden
    public List&lt;Order&gt; getRushOrders() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding a collection for specific users or roles</title>

          <para>It is possible to hide collections for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.HiddenActions">
        <title>How to hide an action</title>

        <para>The mechanism for hiding an action is broadly the same as for
        hiding a property (see <xref linkend="sec.HiddenProperty" />) or a
        collection (see <xref linkend="sec.HiddenCollection" />).</para>

        <sect2>
          <title>Hiding an action permanently</title>

          <para>To prevent a user from viewing an action at all, use the
          <literal moreinfo="none">@Hidden</literal> annotation. This is
          generally used where a <literal moreinfo="none">public</literal>
          method on an object is not intended to be a user action</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    @Hidden
    public void markAsCancelled() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding an action based on the persistence state of the
          object</title>

          <para>As a refinement of the above, an action may be optionally
          hidden using the <classname>@Hidden</classname> annotation based on
          the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to hide the action when the object is transient, use
              <code>@Hidden(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to hide the action when the object is persistent, use
              <code>@Hidden(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Hiding an action under certain conditions</title>

          <para>A <literal moreinfo="none">hideXxx()</literal> method can be
          used to indicate that a particular object's action should be hidden
          under certain conditions, typically relating to the state of that
          instance.</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public boolean hideActionName([ValueOrEntityType param] ...)</literal> </programlisting>

          <para>where the parameter types should match the action itself.
          Returning a value of <code>true</code> indicates that the action
          should be hidden.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public void applyDiscount(int percentage) { ... }
    public boolean hideApplyDiscount() {
        return isWholesaleOrder();
    }
}</programlisting>
        </sect2>

        <sect2>
          <title>Hiding an action for specific users or roles</title>

          <para>It is possible to hide actions for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.Entity.Hidden">
        <title>How to specify that none of an object's members is
        visible</title>

        <para>To when an object is visible, provide a hidden() method:</para>

        <para><programlisting>public class TrackingAction implements Tracking {
   public boolean hidden(){
    ...
   }
}</programlisting>If the function returns true, all properties and actions
        will be hidden from the user, similar to <xref
        linkend="sec.HiddenProperty" />.</para>
      </sect1>

      <sect1 id="sec.DisabledProperty">
        <title>How to prevent a property from being modified</title>

        <para>Preventing the user from modifying a property value is known as
        'disabling' the property. Note that this doesn't prevent the property
        from being modified programmatically.</para>

        <para>The mechanism for disabling a property is broadly the same as
        for disabling a collection (see <xref
        linkend="sec.DisabledCollection" />) or a collection (see <xref
        linkend="sec.DisabledCollection" />).</para>

        <para>For control over the entire object, see <xref
        linkend="sec.Entity.Disabled" />.</para>

        <sect2>
          <title>Disabling a property permanently</title>

          <para>To prevent a user from being able to modify the property at
          all, use the <literal moreinfo="none">@Disabled</literal>
          annotation.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class OrderLine {
    private int quantity;
    @Disabled
    public String getQuantity() { ... }
    public void setQuantity(int quantity) { ... }
    ...
}</programlisting>

          <para>Note that a setter is still required; this is used by the
          framework to recreate the object when pulled back from the
          persistent object store.</para>
        </sect2>

        <sect2>
          <title>Disabling a property based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a property may be optionally
          disabled using the <classname>@Disabled</classname> annotation based
          on the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to disable the property when the object is transient, use
              <code>@Disabled(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to disable the property when the object is persistent, use
              <code>@Disabled(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Disabling a property under certain conditions</title>

          <para>A supporting <literal moreinfo="none">disableXxx()</literal>
          method can be used to disable a particular instance's member under
          certain conditions</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public String disablePropertyName()</literal></programlisting>

          <para>A non-<code>null</code> return value indicates the reason why
          the property cannot be modified. The framework is responsible for
          providing this feedback to the user.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class OrderLine {
    public String getQuantity() { ... }
    public void setQuantity(int quantity) { ... }
    public String disableQuantity() { 
        if (isSubmitted()) {
            return "Cannot alter any quantity after Order has been submitted"; 
        }
        return null;
    }
}</programlisting>

          <para>If there are multiple reasons to disable a property, take a
          look at the
          <classname>org.apache.isis.applib.util.ReasonBuffer</classname>
          helper.</para>
        </sect2>

        <sect2>
          <title>Disabling a property for certain users/roles</title>

          <para>It is possible to disable properties for certain users/roles
          by calling the
          <methodname>DomainObjectContainer#getUser()</methodname> method. See
          <xref linkend="sec.BusinessRulesForCertainUsersOrRoles" />for
          further discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.DisabledCollection">
        <title>How to prevent a collection from being modified</title>

        <para>Preventing the user from adding to or removing from a collection
        is known as 'disabling' the collection.</para>

        <para>The mechanism for disabling a collection is broadly the same as
        for disabling a property (see <xref linkend="sec.DisabledProperty" />)
        or a action (see <xref linkend="sec.DisabledAction" />).</para>

        <sect2>
          <title>Disabling a collection permanently</title>

          <para>Some, though not all, viewers allow the user to directly
          manipulate the contents of a collection. For example, the DnD viewer
          will allow new objects to be "dropped" into a collection, and
          existing objects removed from a collection.</para>

          <para>Although it is possible to associate behaviour with such
          actions (see <xref linkend="sec.AddToRemoveFrom" />), it may be
          preferred to only allow modification through actions. Or, the
          application may be deployed using a viewer that doesn't fully
          support direct manipulation of collections.</para>

          <para>In either case, annotate the collection using the <literal
          moreinfo="none">@Disabled</literal> annotation.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    private List&lt;Order&gt; cancelledOrders = new ArrayList&lt;Order&gt;();
    @Disabled
    public List&lt;Order&gt; getCancelledOrders() { ... }
    private void setCancelledOrders(List&lt;Order&gt; cancelledOrders) { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Disabling a collection based on the persistence state of the
          object</title>

          <para>As a refinement of the above, a collection may be optionally
          disabled using the <classname>@Disabled</classname> annotation based
          on the persistence state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to disable the collection when the object is transient,
              use <code>@Disabled(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to disable the collection when the object is persistent,
              use <code>@Disabled(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Disabling a collection under certain conditions</title>

          <para>A <literal moreinfo="none">disableXxx()</literal> method can
          be used to disable a particular instance's collection under certain
          conditions:</para>

          <para>The syntax is:</para>

          <programlisting><literal moreinfo="none">public String disableCollectionName()</literal> </programlisting>

          <para>For example:</para>

          <programlisting format="linespecific">public class Department {
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt; employees) { ... }
    public void disableEmployees() {
        return isClosed()? "This department is closed" : null;
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Disabling a collection for specific users or roles</title>

          <para>It is possible to disable collections for certain users/roles
          by calling the
          <methodname>DoymainObjectContainer#getUser()</methodname> method.
          See <xref linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for
          further discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.DisabledAction">
        <title>How to prevent an action from being invoked</title>

        <para>Preventing the user from invoking an action is known as
        'disabling' the action.</para>

        <para>The mechanism for disabling an action is broadly the same as for
        disabling a property (see <xref linkend="sec.DisabledProperty" />) or
        a collection (see <xref linkend="sec.DisabledCollection" />).</para>

        <sect2>
          <title>Disabling an action permanently</title>

          <para>It is possible to prevent an action from ever being invoked
          using the <classname>@Disabled</classname> annotation, exactly
          equivalent to the use of the annotation for properties and
          collections. However, it's not a particularly meaningful usecase:
          why display an action that can never be invoked? The only reason we
          can think of is as a placeholder during prototyping - to indicate to
          the user that an action is planned, but has not yet been
          implemented.</para>
        </sect2>

        <sect2>
          <title>Disabling an action based on the persistence state of the
          object</title>

          <para>Whereas annotating an action simply as
          <classname>@Disabled</classname> probably does not make sense (see
          above), it does make sense to optionally disable an action using the
          <classname>@Disabled</classname> annotation based on the persistence
          state of the object:</para>

          <itemizedlist>
            <listitem>
              <para>to disable the action when the object is transient, use
              <code>@Disabled(When.UNTIL_PERSISTED)</code></para>
            </listitem>

            <listitem>
              <para>to disable the action when the object is persistent, use
              <code>@Disabled(When.ONCE_PERSISTED)</code></para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title>Based on the state of the object</title>

          <para>There may be circumstances in which we do not want the user to
          be able to initiate the action at all - for example because that
          action is not appropriate to the current state of the object on
          which the action resides. Such rules are enforced by means of a
          <literal moreinfo="none">disableXxx()</literal> supporting
          method.</para>

          <para>The syntax is:</para>

          <para><programlisting>public String disableActionName([ValueOrEntityType param]...)</programlisting></para>

          <para>A non-<literal>null</literal> return <code>String</code>
          indicates the reason why the action may not be invoked. The
          framework takes responsibility to provide this feedback to the
          user.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(Product p, int quantity) { ... }
    public String disablePlaceOrder(Product p, int quantity) { 
        return isBlackListed()?
            "Blacklisted customers cannot place orders"
            :null;
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Disabling an action for certain users or roles</title>

          <para>It is possible to disable actions for certain users/roles by
          calling the <methodname>DomainObjectContainer#getUser()</methodname>
          method. See <xref
          linkend="sec.BusinessRulesForCertainUsersOrRoles" /> for further
          discussion.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.Entity.Disabled">
        <title>How to specify that none of an object's members can be
        modified/invoked</title>

        <para>Some objects have state which should not be modifiable only
        under certain conditions; for example an invoice can not be modified
        after it has been paid. The viewer is expected to interpret this by
        suppressing any sort of "edit" button.</para>

        <para>To indicate that an object cannot be modified, use the <literal
        moreinfo="none">String disabled(Type type)</literal> method.</para>

        <para>For example:</para>

        <programlisting>public class FeeInvoice implements Invoice {
   public String disabled(Type type){
    ...
   }
}</programlisting>

        <para>The <code>Type</code> is from
        <classname>org.apache.isis.applib.Identifier</classname>:</para>

        <programlisting>    /**
     * What type of feature this identifies.
     */
    public static enum Type {
        CLASS, PROPERTY_OR_COLLECTION, ACTION
    }</programlisting>

        <para>and provides fine grain control over disabling actions and
        properties.</para>

        <para>The return String is null if the the object (action or property)
        is not disabled, or the reason why it is disabled, similar to <xref
        linkend="sec.DisabledProperty" />.</para>

        <para>See also <xref linkend="sec.Entity.Disabled" />.</para>
      </sect1>

      <sect1 id="sec.Immutable">
        <title id="sec.entity.immutable">How to specify that an object is
        immutable (that none of its members can ever be modified)</title>

        <para>Some objects have state which should not be modifiable; for
        example those representing reference data. The viewer is expected to
        interpret this by which suppressing any sort of "edit" button.</para>

        <para>To indicate that an object cannot be modified, use the <literal
        moreinfo="none">@Immutable</literal> annotation.</para>

        <para>For example:</para>

        <programlisting>@Immutable
public class ChasingLetter implements PaymentReclaimStrategy {
    ...
}</programlisting>

        <para>See also <xref linkend="sec.Entity.Disabled" />.</para>
      </sect1>

      <sect1>
        <title>How to validate user input for a property</title>

        <sect2>
          <title>Declarative validation</title>

          <para>For properties that accept a text input string, such as
          <code>String</code> and <code>Date</code>, there are convenient
          mechanisms to validate and/or normalise the values typed in:</para>

          <itemizedlist>
            <listitem>
              <para>For <literal moreinfo="none">Date</literal> and number
              values the <literal moreinfo="none">@Mask</literal> annotation
              may be used.</para>
            </listitem>

            <listitem>
              <para>For <literal moreinfo="none">String</literal> properties
              the <literal moreinfo="none">@RegEx</literal> annotation may be
              used.</para>
            </listitem>
          </itemizedlist>

          <para>More complex validation can also be performed imperatively
          (below).</para>
        </sect2>

        <sect2>
          <title>Imperative validation</title>

          <para>A supporting <literal moreinfo="none">validateXxx()</literal>
          method is used to check that a new value for a property is
          valid.</para>

          <para>If the proffered value is deemed to be invalid then the
          property will not be changed. A non-null return <code>String</code>
          indicates the reason why the member cannot be modified/action be
          invoked; the framework is responsible for providing this feedback to
          the user.</para>

          <para>The syntax is:</para>

          <para><programlisting>public String validatePropertyName(PropertyType param)</programlisting></para>

          <para>where <literal moreinfo="none">PropertyType</literal> is the
          same type as that of the property itself.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Exam {
    public int getMark() { ... }
    public void setMark(int mark) { ... }
    public validateMark(int mark) {
        return !withinRange(mark)? "Mark must be in range 0 to 30":null;
    }
    private boolean withinRange(int mark) { return mark &gt;= 0 &amp;&amp; mark &lt;= 30; }
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to validate an object being added or removed from a
        collection</title>

        <para>A <literal moreinfo="none">validateAddToXxx()</literal> method
        can be used to check that an object is valid to be added to a
        collection. Conversely, the
        <methodname>validateRemoveFromXxx()</methodname> method can be used to
        check that it is valid to remove an object from a collection is
        valid.</para>

        <para>The syntax is:</para>

        <para><programlisting>public String validateAddToCollectionName(EntityType param)</programlisting></para>

        <para>and</para>

        <programlisting>public String validateRemoveFromCollectionName(EntityType param)</programlisting>

        <para>A non-<code>null</code> return <code>String</code> indicates the
        reason why the object cannot be added/removed, and the viewing
        mechanism will display this to the user.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Department {
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt; employees) { ... }
    public String validateAddToEmployee(Employee employee) {
        return employee.isRetired()?
            "Cannot add retired employees to department"
            :null;
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to validate an action parameter argument</title>

        <sect2>
          <title>Declarative validation</title>

          <para>For parameters that accept a text input string, such as
          <code>String</code> and <code>Date</code>, there are convenient
          mechanisms to validate and/or normalise the values typed in:</para>

          <itemizedlist>
            <listitem>
              <para>For <literal moreinfo="none">Date</literal> and number
              values the <literal moreinfo="none">@Mask</literal> annotation
              may be used.</para>
            </listitem>

            <listitem>
              <para>For <literal moreinfo="none">String</literal> parameters
              the <literal moreinfo="none">@RegEx</literal> annotation may be
              used.</para>
            </listitem>
          </itemizedlist>

          <para>More complex validation can also be performed imperatively
          (below).</para>
        </sect2>

        <sect2>
          <title>Imperative validation</title>

          <para>A <literal moreinfo="none">validateXxx()</literal> method is
          used to check that the set of arguments used by an action method is
          valid. If the arguments are invalid then the framework will not
          invoke the action.</para>

          <para>The syntax is:</para>

          <para><programlisting>public String validate&lt;ActionName&gt;([ValueOrEntityType param]...)</programlisting></para>

          <para>A non-<code>null</code> return <classname>String</classname>
          indicates the reason why the member cannot be modified/action be
          invoked, and the viewing mechanism will display this feedback to the
          user.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(Product p, int quantity) { ... }
    public String validatePlaceOrder(Product p, int quantity) {
        if (p.isOutOfStock()) { return "Product is out of stock"; }
        if (quantity &lt;= 0) { return "Quantity must be a positive value"; }
        return null;
    }
    ...
}</programlisting>

          <para>For complex validation, you may wish to use the
          <classname>org.apache.isis.applib.util.ReasonBuffer</classname>
          helper class.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.MustSpecify">
        <title>How to validate declaratively using @MustSatisfy</title>

        <para>The <literal>@MustSatisfy</literal> annotation is an alternative
        to using imperative validation, allowing validation rules to be
        captured in an (implementation of a)
        <classname>org.apache.isis.applib.spec.Specification</classname>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class DomainObjectWithMustSatisfyAnnotations extends AbstractDomainObject {

    private String lastName;
    @MustSatisfy(SpecificationRequiresFirstLetterToBeUpperCase.class)
    public String getLastName() {
        resolve(lastName);
        return lastName;
    }
    public void setLastName(String lastName) {
        this.lastName = lastName;
        objectChanged();
    }

    public void changeLastName(
            @MustSatisfy(SpecificationRequiresFirstLetterToBeUpperCase.class)
            String lastName
            ) {
        setLastName(lastName);
    }

}</programlisting>

        <para>To help you write your own
        <classname>Specification</classname>s, there are some adapter classes
        in <package>org.apache.isis.applib.specs</package>:</para>

        <itemizedlist>
          <listitem>
            <para><classname>AbstractSpecification</classname>, which
            implements <classname>Specification</classname> and takes
            inspiration from the <ulink
            url="http://code.google.com/p/hamcrest/">Hamcrest</ulink>
            library's <classname>TypeSafeMatcher</classname> class</para>
          </listitem>

          <listitem>
            <para><classname>SpecificationAnd</classname>, which allows a set
            of <classname>Specification</classname>s to be grouped together
            and require that <emphasis>all</emphasis> of them are
            satisfied</para>
          </listitem>

          <listitem>
            <para><classname>SpecificationOr</classname>, which allows a set
            of <classname>Specification</classname>s to be grouped together
            and require that <emphasis>at least one</emphasis> of them is
            satisfied</para>
          </listitem>

          <listitem>
            <para><classname>SpecificationNot</classname>, which requires that
            the provided <classname>Specification</classname> is
            <emphasis>not</emphasis> satisfied</para>
          </listitem>
        </itemizedlist>
      </sect1>
    </chapter>

    <chapter>
      <title>How to provide drop-downs and default values</title>

      <abstract>
        <para>How-to make actions easier to use from an end-user perspective,
        by providing sets of choices and defaults.</para>
      </abstract>

      <para>Invoking actions or setting properties requires that the user
      specify a valid value; of the correct type, and that passes any
      validation rules that may have been defined. To make things are easier
      for the user, you can provide lists of choices; viewers typically render
      these values in a drop-down list box.</para>

      <para>In a similar vein, there may be a default value for an action
      parameter; this can also be specified.</para>

      <sect1>
        <title>How to specify a set of choices for a property</title>

        <para>The simplest way to provide the user with a set of choices for a
        property (possibly rendered as a drop-down list, for example) is to
        ensure that the type used by the property is marked up as
        <code>@Bounded</code> (see <xref linkend="sec.Bounded" />).</para>

        <para>However, this is not always appropriate. For example you might
        wish to provide the user with the choice of all the
        <classname>Address</classname>es known for that
        <classname>Customer</classname>, with the most recently-used address
        as the default.</para>

        <para>The syntax for specifying a list of choices is either:</para>

        <para><programlisting>public Collection&lt;PropertyType&gt; choicesPropertyName()</programlisting></para>

        <para>or alternatively</para>

        <programlisting>public PropertyType[] choicesPropertyName()</programlisting>

        <para>where <literal moreinfo="none">PropertyType</literal> is the
        same type as that of the property itself.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Order {
    public Address getShippingAddress() { ... }
    public void setShippingAddress() { ... }
    public List&lt;Address&gt; choicesShippingAddress() {
        return getCustomer().allActiveAddresses();
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>How to specify a set of choices for an action parameter</title>

        <para>The programmer may provide a set of choices for the value of any
        or all of the parameters of an action. These will be made available to
        the user - for example as a drop-down list.</para>

        <para>If the type of the parameter is annotated with <literal
        moreinfo="none">@Bounded</literal>, then it is not necessary to
        specify the choices for that parameter, as the user will automatically
        be offered the full set to choose from.</para>

        <para>If this isn't the case, then - as for defaults - there are two
        different ways to specify parameters; either per parameter, or for all
        parameters.</para>

        <sect2>
          <title>Per parameter syntax (preferred)</title>

          <para>The per-parameter form is simpler and generally
          preferred.</para>

          <para>The syntax is:</para>

          <programlisting>public List&lt;ParameterType&gt; choicesNActionName()</programlisting>

          <para>where N indicates the 0-based parameter number.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public Order placeOrder(
            Product product,
            @Named("Quantity") 
            int quantity) {
        ...
    }
    public List&lt;Product&gt; choices0PlaceOrder() {
        return lastFiveProductsOrderedBy(this.getCustomer());
    }
    public List&lt;Integer&gt; choices1PlaceOrder() {
        return Arrays.asList(1,2,3,4,5);
    }
    ....
}</programlisting>
        </sect2>

        <sect2>
          <title>All parameters syntax</title>

          <para>The alternative mechanism is to supply all the parameter
          choices in one go:</para>

          <para><programlisting>public Object[] choices&lt;ActionName&gt;([&lt;parameter type&gt; param]...)</programlisting></para>

          <para>returning an array, which must have one element per parameter
          in the method signature. Each element of the array should itself
          either be an array or a list, containing the set of values
          representing the choices for that parameter, or <literal
          moreinfo="none">null</literal> if there are no choices to be
          specified for that parameter.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Order {
    public Order placeOrder(
            Product product,
            @Named("Quantity") 
            int quantity) {
        ...
    }
    public Object[] choicesPlaceOrder(
            Product product,
            int quantity) {
        return new Object[] {
            lastFiveProductsOrderedBy(this.getCustomer()).toArray(), 
            Arrays.asList(1,2,3,4,5)
        };
    }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1 id="sec.Bounded">
        <title>How to specify that a class of objects has a limited number of
        instances</title>

        <para>Sometimes an entity may only have a relatively small number of
        instances, for example the types of credit cards accepted (Visa,
        Mastercard, Amex). Viewers will typically expected to render the
        complete set of instances as a drop down list whenever the object type
        is used (ie as a property or action parameter).</para>

        <para>To indicate that a class has a limited number of instances, use
        the <classname>@Bounded</classname> annotation. Note that there is an
        implied expectation is that the list of objects is small, and
        relatively cheap to obtain from the object store.</para>

        <para>An alternative way to specify a selection of objects is using
        the <classname>choicesXxx()</classname> supporting methods.</para>

        <para>For example:</para>

        <programlisting>@Bounded
public class PaymentMethod {
    ...
}</programlisting>

        <para>Alternatively, you might want to use a (Java) <code>enum</code>,
        because these are implicitly bounded.</para>
      </sect1>

      <sect1>
        <title>How to find an entity (for an action parameter or property)
        using auto-complete</title>

        <para>Some viewers (eg the Wicket viewer) allow an entity to be
        specified (as an argument for an action parameter, or as the new value
        of a property) by enabling the user to type its title. The framework
        then searches for a matching instance, presenting them in a drop-down
        list.</para>

        <para>This is accomplished using two annotations. The
        <classname>@AutoComplete</classname> annotation is used on the entity
        type itself:</para>

        <programlisting>@AutoComplete(repository=Customers.class)
public class Customer {
    ...
}</programlisting>

        <para>The <code>repository</code> attribute indicates the class of the
        domain service that has an autoComplete() method. This is required to
        accept a single <classname>String</classname> and return a
        <classname>List</classname> of candidates:</para>

        <programlisting>public class Customers {
    ...
    @Hidden
    public List&lt;Property&gt; autoComplete(String searchPhrase) {        
        return allMatches(new QueryDefault&lt;Customer&gt;("customers_findByName", "name", searchPhrase));
    }
}</programlisting>

        <para>If required, a different action name than "autoComplete" can be
        specified.</para>
      </sect1>

      <sect1>
        <title>How to specify default values for an action parameter</title>

        <para>When an action is about to be invoked, then default values can
        be provided for any or all of its parameters.</para>

        <para>There are two different ways to specify parameters; either per
        parameter, or for all parameters.</para>

        <sect2>
          <title>Per-parameter syntax (preferred)</title>

          <para>The per-parameter form is simpler and generally to be
          preferred.</para>

          <para>The syntax is:</para>

          <programlisting>public ParameterType defaultNActionName()</programlisting>

          <para>where N indicates the 0-based parameter number. For
          example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
             Product product,
             @Named("Quantity") 
             int quantity) {
        ...
    }
    public Product default0PlaceOrder() {
        return productMostRecentlyOrderedBy(this.getCustomer());
    }
    public int default1PlaceOrder() {
        return 1;
    }
}</programlisting>
        </sect2>

        <sect2>
          <title>All parameters syntax</title>

          <para>The syntax for specifying all the parameter default values in
          one go is:</para>

          <para><programlisting>public Object[] defaultActionName([ValueOrEntityType param]...)</programlisting></para>

          <para>returning an array which must have one element per parameter
          in the action method signature of corresponding default
          values.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
            Product product,
            @Named("Quantity") 
            int quantity) {
        ...
    }
    public Object[] defaultPlaceOrder(
            Product product,
            int quantity) {
        return new Object[] {
            productMostRecentlyOrderedBy(this.getCustomer()),
            1
        };
    }
    ...
}</programlisting>
        </sect2>
      </sect1>
    </chapter>

    <chapter>
      <title>How to derive properties and collections, and other
      side-effects</title>

      <abstract>
        <para>How-to derive properties and collections from persisting state,
        and provide other side-effects.</para>
      </abstract>

      <para>The Isis viewers will automatically render the state of properties
      and collections, but the values of such need not be persisted; they can
      be derived from other information available to the object.</para>

      <para>For collections</para>

      <sect1 id="sec.DerivedProperty">
        <title>How to make a derived property</title>

        <sect2>
          <title>Read-only</title>

          <para>Most derived properties are read-only, their value being
          derived from other information available to the object.</para>

          <para>Omitting the mutator (<code>setXxx()</code>) method for a
          property indicates both that the field is derived, and is not be
          persisted.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Employee {
    public Department getDepartment() { ... }
    ...

    // this is the derived property
    public Employee getManager() {
        if (getDepartment() == null) { return null; }
        return getDepartment().getManager();
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Read-write</title>

          <para>A derived property can be made updateable (in that it takes
          the provided value and does something sensible with it) by providing
          a <code>modifyXxx()</code> supporting method:</para>

          <programlisting format="linespecific">public class Employee {
    public Department getDepartment() { ... }
    ...

    // this is the derived property
    public Employee getManager() { ... }

    // this makes the derived property modifiable
    public void modifyManager(Employee manager) {
        if (getDepartment() == null) { return; }
        getDepartment().modifyManager(manager);
    }

    ...
}</programlisting>

          <para>Note how the implementation of such a <code>modifyXxx()</code>
          method typically modifies the original source of the information
          (the <classname>Department</classname> object).</para>

          <para>Alternatively, if you prefer to have a setter, then you can
          use Isis' <classname>@NotPersisted</classname> attribute.</para>

          <programlisting format="linespecific">public class Employee {
    public Department getDepartment() { ... }
    ...

    @NotPersisted
    public Employee getManager() { ... }
    public void setManager(Employee manager) {
        if (getDepartment() == null) { return; }
        getDepartment().modifyManager(manager);
    }
    ...
}</programlisting>

          <note>
            <para>If you use this approach, then for some object stores you
            may also need to annotate the property to exclude it. For example
            the JDO/DataNucleus object store requires the property being
            annotated with
            <classname>@javax.jdo.annotations.NotPersistent</classname>.</para>
          </note>
        </sect2>
      </sect1>

      <sect1 id="sec.DerivedCollection">
        <title>How to make a derived collection</title>

        <para>Collections can be derived by omitting the mutator (the same way
        as properties, see <xref linkend="sec.DerivedProperty" />).</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Department {
    // Standard collection
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt;) { ... }

    // Derived collection
    public List&lt;Employee&gt; getTerminatedEmployees() {
        List&lt;Employee&gt; terminatedEmployees = new ArrayList&lt;Employee&gt;();
        for(Employee e: employees) {
            if (e.isTerminated()) {
                addTo(terminatedEmployees, e);
            }
        }
        return terminatedEmployees;
    }
    ...
}</programlisting>

        <para>Derived collections are not persisted, though may be modified if
        there is an <code>addToXxx()</code> or <code>removeFromXxx()</code>
        supporting method. As for derived properties, the implementations of
        these mutators change the underlying data. For example:</para>

        <programlisting format="linespecific">public class Department {
    ...

    public void addToTerminatedEmployees(Employee employee) {
        employee.setTerminated(true);
    }
    public void removeFromTerminatedEmployees(Employee employee) {
        employee.setTerminated(false);
    }
}</programlisting>
      </sect1>

      <sect1>
        <title>How to inline the results of a query-only repository
        action</title>

        <para>While derived properties (<xref
        linkend="sec.DerivedProperty" />) and derived collections (<xref
        linkend="sec.DerivedCollection" />) typically "walk the graph" to
        associated objects, there is nothing to prevent the returned value
        being the result of invoking a repository (domain service)
        action.</para>

        <para>For example:</para>

        <programlisting>public class Customer {
    ...
    public List&lt;Order&gt; getMostRecentOrders() {
        return orderRepo.findMostRecentOrders(this, 5);
    }
}</programlisting>
      </sect1>

      <sect1 id="sec.ModifyAndClear">
        <title>How to trigger other behaviour when a property is
        changed</title>

        <para>If you want to invoke functionality whenever a property is
        changed by the user, then you should create a supporting <literal
        moreinfo="none">modifyXxx()</literal> method and include the
        functionality within that. The syntax is:</para>

        <programlisting>public void modifyPropertyName(PropertyType param)</programlisting>

        <para>Why not just put this functionality in the setter? Well, the
        setter is used by the object store to recreate the state of an already
        persisted object. Putting additional behaviour in the setter would
        cause it to be triggered incorrectly.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Order() {
    public Integer getAmount() { ... }
    public void setAmount(Integer amount) { ... }
    public void modifyAmount(Integer amount) {
        setAmount(amount);
        addToTotal(amount);
    }
    ...
}</programlisting>

        <para>Here the <literal moreinfo="none">modifyAmount()</literal>
        method also calls the <literal moreinfo="none">addToTotal()</literal>
        call as well as the <literal moreinfo="none">setAmount()</literal>
        method. We don't want this <methodname>addToCall()</methodname> method
        to be called when pulling the object back from the object store, so we
        put it into the modify, not the setter.</para>

        <para>You may optionally also specify a <code>clearXxx()</code> which
        works the same way as modify <literal moreinfo="none">modify</literal>
        <literal moreinfo="none">Xxx()</literal> but is called when the
        property is cleared by the user (i.e. the current value replaced by
        nothing). The syntax is:</para>

        <programlisting>public void clearPropertyName()</programlisting>

        <para>To extend the above example:</para>

        <programlisting format="linespecific">public class Order() {
    public Integer getAmount() { ... }
    public void setAmount(Integer amount) { ... }
    public void modifyAmount(Integer amount) { ... }
    public void clearAmount() {
        removeFromTotal(this.amount);
        setAmount(null);
    }
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.AddToRemoveFrom">
        <title>How to trigger other behaviour when an object is added or
        removed</title>

        <para>A collection may have a corresponding <literal
        moreinfo="none">addToXxx()</literal> and/or <literal
        moreinfo="none">removeFromXxx()</literal> method. If present, and
        direct manipulation of the contents of the connection has not been
        disabled (see <xref linkend="sec.DisabledCollection" />), then they
        will be called (instead of adding/removing an object directly to the
        collection returned by the accessor).</para>

        <para>The reason for this behaviour is to allow other behaviour to be
        triggered when the contents of the collection is altered. That is, it
        is directly equivalent to the supporting <literal
        moreinfo="none">modifyXxx()</literal> and <literal
        moreinfo="none">clearXxx()</literal> methods for properties (see <xref
        linkend="sec.ModifyAndClear" />).</para>

        <para>The syntax is:</para>

        <para><programlisting>public void addTo&lt;CollectionName&gt;(EntityType param)</programlisting></para>

        <para>and</para>

        <programlisting>public void removeFromCollectionName(EntityType param)</programlisting>

        <para>where <literal moreinfo="none">EntityType</literal> is the same
        type as the generic collection type.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Employee { ... }

public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List &lt;Employee&gt; getEmployees() {
        return employees;
    }
    private void setEmployees(List&lt;Employee&gt; employees) { 
        this.employees = employees;
    }
    public void addToEmployees(Employee employee) {
        numMaleEmployees += countOneMale(employee);
        numFemaleEmployees += countOneFemale(employee);
        employees.add(employee);
    }
    public void removeFromEmployees(Employee employee) {
        numMaleEmployees -= countOneMale(employee);
        numFemaleEmployees -= countOneFemale(employee);
        employees.remove(employee);
    }
    private int countOneMale(Employee employee) { return employee.isMale()?1:0; }
    private int countOneFemale(Employee employee) { return employee.isFemale()?1:0; }

    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.MutualRegistrationPattern">
        <title>How to set up and maintain bidirectional relationships</title>

        <para>The <methodname>modifyXxx()</methodname> and
        <methodname>clearXxx()</methodname> methods (see <xref
        linkend="sec.ModifyAndClear" />) can be used to setup bidirectional
        relationships. This is typically done with 1:m relationships, eg
        between <classname>Order</classname> and
        <classname>OrderLine</classname>, or <classname>Department</classname>
        and <classname>Employee</classname>.</para>

        <para>The recommended way of maintaining a bidirectional relationship
        is to use the 'mutual registration pattern', a write-up of which can
        be found at <ulink
        url="http://www.two-sdg.demon.co.uk/curbralan/papers/MutualRegistration.pdf">http://www.two-sdg.demon.co.uk/curbralan/papers/MutualRegistration.pdf</ulink>.
        The general idea is that one side of the relationship is responsible
        for maintaining the associations, while the other side simply
        delegates.</para>

        <para>To implement this in <emphasis>Isis</emphasis> for a 1:m
        relationship, use the <methodname>addToXxx()</methodname> /
        <methodname>removeFromXxx()</methodname> and
        <methodname>modifyXxx()</methodname> /
        <methodname>clearXxx()</methodname> methods.</para>

        <para>For example:</para>

        <programlisting>public class Department {
    private List&lt;Employee&gt; employees = new ArrayList&lt;Employee&gt;();
    public List&lt;Employee&gt; getEmployees() { ... }
    private void setEmployees(List&lt;Employee&gt; employees) { ... }
    public void addToEmployees(Employee e) {
        if(e == null || employees.contains(e)) return;
        e.setDepartment(this);
        employees.add(e);
    }
    public void removeFromEmployees(Employee e) {
        if(e == null || !employees.contains(e)) return;
        e.setDepartment(null);
        employees.remove(e);
    }
    ...
}</programlisting>

        <para>and</para>

        <programlisting>public class Employee {
    private Department department;
    public Department getDepartment() { ... }
    private void setDepartment(Department department) { ... }
    public void modifyDepartment(Department d) {
        if(d==null || department==d) return;
        if(department != null) {
            department.removeFromEmployees(this);
        }
        d.addToEmployees(this);
    }
    public void clearDepartment() {
        if(department==null) return;
        department.removeFromEmployees(this);
    }
    ...
}</programlisting>

        <note>
          <para>For some object stores this explicit coding may not be
          necessary; the object store automatically maintains the
          relationship.</para>
        </note>
      </sect1>
    </chapter>

    <chapter>
      <title>How to provide additional UI hints</title>

      <abstract>
        <para>How to override Isis' defaults for presentation.</para>
      </abstract>

      <para>With the exception of value types for action parameters (see <xref
      linkend="sec.ActionParameterNames" />), Isis can normally infer a
      reasonable name for entity/service and its class members. However, these
      defaults can be overridden if required. One possible case is where the
      desired name is a reserved word in Java (eg "default", or
      "package").</para>

      <para>A slightly more advanced use-case is to specify an icon not for an
      entity's type, but for an entity instance. Typically this reflects that
      instance's state, eg with an overlay on top of the base icon. For
      example, this allows the user to distinguish between an
      <classname>Order</classname> that has been placed vs one that has been
      shipped.</para>

      <sect1>
        <title condition="j#">How to specify a name and/or description for an
        object</title>

        <para>By default, the name (or type) of an object, as displayed to the
        user will be the class name. However, if an <literal
        moreinfo="none">@Named</literal> annotation is included, then this
        will override the default name. This might be used to include
        punctuation or other characters that may not be used within a class
        name, or when - for whatever reason - the name of the class includes
        technical artifacts (for example project-defined prefixes or
        suffices). It is also useful if the required name cannot be used
        because it is a keyword in the language.</para>

        <para>By default the framework will create a plural version of the
        object name by adding an 's' to singular name, or a 'ies' to names
        ending 'y'. For irregular nouns or other special case, the
        <code>@Plural</code> annotation may be used to specify the plural form
        of the name explicitly.t</para>

        <para>The programmer may optionally also provide a <literal
        moreinfo="none">@DescribedAs</literal> annotations, containing a brief
        description of the object's purpose, from a user perspective. The
        framework will make this available to the user in a form appropriate
        to the user interface style - for example as a tooltip.</para>

        <para>For example:</para>

        <programlisting>@Named("Customer")
@Plural("Customers")
@DescribedAs("Individuals or organizations that have either "+
             "purchased from us in the past or "+
             "are likely to in the future")
public class CustomerImpl implements ICustomer {
    ...
}</programlisting>

        <note>
          <para>There is an entirely separate mechanism for dealing with
          Internationalisation, details of which can be found in the core
          documentation.</para>
        </note>
      </sect1>

      <sect1>
        <title>How to specify a name and/or description for a property</title>

        <sect2>
          <title>Specifying the name for a property</title>

          <para>By default the framework will use the property name itself to
          label the property on the user interface. If you wish to override
          this, use the <literal moreinfo="none">@Named </literal>annotation
          on the property.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer() {
    @Named("Given Name")
    public String getFirstName() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Specifying a description for a property</title>

          <para>An additional description can be provided on a property using
          the <literal moreinfo="none">@DescribedAs</literal> annotation. The
          framework will take responsibility to make this description
          available to the user, for example in the form of a tooltip.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer() {
    @DescribedAs("The customer's given name")
    public String getFirstName() { ... }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify a name and/or description for a
        collection</title>

        <sect2>
          <title>Specifying the name for a collection</title>

          <para>By default the framework will use the collection name itself
          to label the collection on the user interface. If you wish to
          override this, use the <literal moreinfo="none">@Named</literal>
          annotation on the collection.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @Named("Placed Orders")
    public List&lt;Order&gt; getOrders() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Specifying a description for a collection</title>

          <para>An additional description can be provided on a collection
          using the <literal moreinfo="none">@DescribedAs</literal>
          annotation. The framework will take responsibility to make this
          description available to the user, for example in the form of a
          tooltip.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @DescribedAs("Those orders that have been placed (and possibly shipped) " + 
                 "by this customer given name by which this customer is known")
    public List&lt;Order&gt; getOrders() { ... }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify names and/or description for an action</title>

        <sect2>
          <title>Specifying the name for an action</title>

          <para>By default the framework will use the action name itself to
          label the menu item on the user interface. If you wish to override
          this, use the <literal moreinfo="none">@Named</literal> annotation
          on the action.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @Named("Place Order")
    public void createOrder() { ... }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Specifying a description for a collection</title>

          <para>An additional description can be provided on an action using
          the <literal moreinfo="none">@DescribedAs</literal> annotation. The
          framework will take responsibility to make this description
          available to the user, for example in the form of a tooltip.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @DescribedAs("Places an order, causing a shipping note "+
                 "to be generated and invoice to be dispatched")
    public void createOrder() { ... }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to specify the icon for an individual object's
        state</title>

        <para>As discussed in <xref
        linkend="sec.HowToSpecifyTheIconForAnObjectsClass" />, the
        <code>iconName()</code> method may be used to specify an object. The
        value returned from this method need not be static, and so it can be
        used to represent the state of an individual object.</para>

        <para>For example, an instance of <classname>Product</classname> could
        use a photograph of the product as an icon, using:</para>

        <programlisting format="linespecific">public class Product {
    public String iconName() {
        return "Product-" + getPhotograph();
    }
    ...
}</programlisting>

        <para>Alternatively, an <classname>Order</classname> might vary the
        icon according to the status of the object:<programlisting>public class Order {
    public String iconName() {
        return "Order-" + getStatus();
    }
    ...
}</programlisting></para>
      </sect1>
    </chapter>

    <chapter>
      <title>How to deal with errors</title>

      <abstract>
        <para>How to inform the user if an error occurs.</para>
      </abstract>

      <para>Things go wrong. Isis handles many of the usual error conditions,
      but your app may also wish to notify the user also when something goes
      awry.</para>

      <sect1 id="sec.passMessagesAndErrors">
        <title>How to pass a messages and errors back to the user</title>

        <para>Sometimes, within an action it is necessary or desirable to pass
        a message to the user, for example to inform them of the results of
        their action ('5 payments have been issued') or that the action was
        not successful ('No Customer found with name John Smith').</para>

        <para><code>DomainObjectContainer</code> defines three methods for
        this purpose:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>informUser(String message)</methodname></para>

            <para>Inform the user of some event. The user should not be
            expected to acknowledge the message; typically the viewer will
            display the message for a period of time in a non-modal
            notification window.</para>
          </listitem>

          <listitem>
            <para><methodname>warnUser(String message)</methodname></para>

            <para>Warn the user of some event. Because this is more serious,
            the viewer should require the user to acknowledge the
            message.</para>
          </listitem>

          <listitem>
            <para><methodname>raiseError(String message)</methodname></para>

            <para>Indicate that a serious application error has occurred. The
            viewer should again require the user to acknowledge the message,
            and quite possibly indicate further steps that the user should
            perform (eg notify the help desk).</para>

            <para>In this last case, no changes will be made to any objects
            (the transaction is aborted).</para>
          </listitem>
        </itemizedlist>

        <para>The precise mechanics of how each of these messages is rendered
        visible to the user is determined by the viewer being used.</para>
      </sect1>

      <sect1>
        <title>How to deal with an unexpected error</title>

        <para>An alternative to calling
        <code>DomainObjectContainer#raiseError()</code> (see <xref
        linkend="sec.passMessagesAndErrors" />) is to simply throw an
        org.apache.isis.applib.ApplicationException. Which you use is a matter
        of style, because the behaviour is exactly the same; internally
        <code>raiseError()</code> just throws the
        <code>ApplicationException</code>.</para>
      </sect1>
    </chapter>

    <chapter>
      <title>How to handle entity persistence lifecycle</title>

      <abstract>
        <para>How to hook into the entity persistence lifecycle and handle
        specific scenarios</para>
      </abstract>

      <para>Isis automatically persists domain entities, performing both lazy
      loading and dirty object tracking. As an application programmer you can
      get visibility into and influence this behaviour.</para>

      <sect1 id="sec.DefaultPropertyValue">
        <title>How to set up the initial value of a property
        programmatically</title>

        <para>After an object has been created (see <xref
        linkend="sec.HowToCreateAnObject" />), there are several different
        ways to setup the initial values for an object's properties.</para>

        <sect2>
          <title>By each property's default values</title>

          <para>Firstly, the default value for a property can be supplied
          using a supporting <methodname>defaultXxx()</methodname> method. The
          syntax for specifying a default value is:</para>

          <para><programlisting>public PropertyType defaultPropertyName()</programlisting></para>

          <para>where <literal moreinfo="none">PropertyType</literal> is the
          same type as that of the property itself.</para>

          <programlisting format="linespecific">public class Order {
    public Address getShippingAddress() { ... }
    public void setShippingAddress() { ... }
    public Address defaultShippingAddress() {
        return getCustomer().normalAddress();
    }
    ...
}</programlisting>
        </sect2>

        <sect2>
          <title>By the <methodname>created()</methodname> lifecycle
          method</title>

          <para>Alternatively, the domain object may choose to initialize its
          property values in the <literal moreinfo="none">created()</literal>
          lifecycle method (see <xref linkend="sec.LifecycleMethods" />). This
          is called after any <methodname>defaultXxx()</methodname> methods
          are called.</para>
        </sect2>

        <sect2>
          <title>Programmatically, by the creator</title>

          <para>Third, and perhaps most obviously, the creator of the object
          could initialize the properties of the object immediately after
          calling <methodname>newTransientInstance(...)</methodname>. This
          would be appropriate if the creator had reason to override any
          values setup in the <methodname>defaultXxx()</methodname> or
          <methodname>created()</methodname> methods discussed above.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.LifecycleMethods">
        <title>How to insert behaviour into the object life cycle</title>

        <para><emphasis>Apache Isis</emphasis> is responsible for managing the
        object lifecycle, persisting, updating or removing objects from the
        persistent object store as required. For many applications the domain
        objects are unaware of this. If required, though, an object can
        provide callback methods (all optional) so that the framework can
        notify it of its persistence state.</para>

        <para>For example, the <literal
        moreinfo="none"><methodname>persisted</methodname></literal>() method
        is called after an object has been persisted. This could be used to
        setup a reverse association that should only be created once the new
        object has been persisted.</para>

        <para>The full list of callbacks is shown below.</para>

        <table>
          <title>Object lifecycle methods</title>

          <tgroup cols="2">
            <colspec align="left" colwidth="105" />

            <colspec align="left" />

            <thead>
              <row>
                <entry align="center">Method</entry>

                <entry align="center">When called by framework</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><methodname>created()</methodname></entry>

                <entry>following the logical creation of the object (that is,
                after <methodname>newTransientInstance()</methodname> has been
                called)</entry>
              </row>

              <row>
                <entry><methodname>loading()</methodname></entry>

                <entry>when a persistent object is about to be loaded into
                memory</entry>
              </row>

              <row>
                <entry><methodname>loaded()</methodname></entry>

                <entry>once the persistent object has just been loaded into
                memory</entry>
              </row>

              <row>
                <entry><methodname>persisting()</methodname> or
                <methodname>saving()</methodname></entry>

                <entry>just before a transient object is first
                persisted.</entry>
              </row>

              <row>
                <entry><methodname>persisted()</methodname> or
                <methodname>saved()</methodname></entry>

                <entry>just after a transient object is first
                persisted.</entry>
              </row>

              <row>
                <entry><methodname>updating()</methodname></entry>

                <entry>after any property on a persistent object has been
                changed and just before this change is persisted</entry>
              </row>

              <row>
                <entry><methodname>updated()</methodname></entry>

                <entry>after a changed property on a persistent object has
                been persisted</entry>
              </row>

              <row>
                <entry><methodname>removing()</methodname> or
                <methodname>deleting()</methodname></entry>

                <entry>when a persistent object is just about to be deleted
                from the persistent object store.</entry>
              </row>

              <row>
                <entry><methodname>removed()</methodname> or
                <methodname>deleted()</methodname></entry>

                <entry>when a persistent object has just been deleted from the
                persistent object store.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect1>

      <sect1>
        <title>How to ensure object is in valid state</title>

        <para>A <methodname>validate()</methodname> method may be added to
        provided validation at object level, prior to making an object
        persistent.</para>

        <para>The syntax is:</para>

        <programlisting>public String validate()</programlisting>

        <para>A non-<code>null</code> value is the taken to be the reason why
        the object cannot be saved.</para>

        <para>This is particularly useful for validating fields in relation to
        each other.</para>

        <para>For example:</para>

        <programlisting>public class Booking {
    private Date fromDate;
    public Date getFromDate() {...}
    public void setFromDate(Date d) {...}
    
    private Date toDate;
    public Date getToDate() {...}
    public void setToDate(Date d) {...}

    public String validate() {
        if (fromDate.getTicks() &gt; toDate.getTicks()) {
            return "From Date cannot be after To Date";
        }
        return null;
    }
    ...
}</programlisting>

        <para>This will prevent the user from saving a transient
        <code>Booking</code> where the From Date falls after the To Date. Note
        that in this example, the two date properties could also have their
        own individual validate methods - for example in order to test that
        each date was after today.</para>

        <warning>
          <para>At the time of writing, the <code>validate()</code> method is
          called only when the object is first saved, not when it is
          subsequently updated. For validation of subsequent updates, the
          workaround is necessary to build the validation logic into the
          individual property validation methods (though these could delegate
          to a common <code>validate()</code> method).</para>

          <para>See <ulink
          url="https://issues.apache.org/jira/browse/ISIS-18">ISIS-18</ulink>
          for the status of this issue.</para>
        </warning>
      </sect1>

      <sect1>
        <title condition="vb">How to specify that an object should not be
        persisted</title>

        <para>Non-persisted objects are intended to be used as view models;
        they aggregate some state with respect to a certain process. This may
        be read-only (eg a projection of certain informaiton) or read-write
        (eg a wizard-like process object). Either way, the viewer is expected
        to interpret this by not providing any sort of automatic "save" menu
        item if such an object is returned to the
        <acronym>GUI</acronym>.</para>

        <para>Non-persisted objects that are read-only are typically also
        marked as immutable (see <xref linkend="sec.Immutable" />).</para>

        <para>To indicate that an object cannot be persisted, use the <literal
        moreinfo="none">@NotPersistable</literal> annotation.</para>
      </sect1>

      <sect1 id="sec.ResolveAndObjectChanged">
        <title>How to perform lazy loading (generally done
        automatically)</title>

        <para>The <classname>DomainObjectContainer</classname> provides the
        <methodname>resolve()</methodname> method in order to lazily resolve
        the value of a property or a collection. In earlier versions of the
        framework it was necessary to call this method prior to accessing or
        mutating any property or collection. This is no longer required
        because <emphasis>Apache Isis</emphasis> uses bytecode enhancement to
        automatically call this method.</para>

        <para>While it is possible to disable this bytecode enhancement using
        <filename>isis.properties</filename> file, this is not generally
        recommended. If it is disabled then the
        <methodname>resolve()</methodname> method may need to be called
        manually.</para>
      </sect1>

      <sect1>
        <title>How to perform dirty object tracking (generally done
        automatically)</title>

        <para>The <classname>DomainObjectContainer</classname> provides the
        <methodname>objectChanged()</methodname> method in order to mark an
        object's state as having changed, and therefore requiring an update to
        the persistent object store. In earlier versions of the framework it
        was necessary to call this method after mutating any the property or
        collection. This is no longer required because <emphasis>Apache
        Isis</emphasis> uses bytecode enhancement to automatically call this
        method.</para>

        <para>While it is possible to disable this bytecode enhancement using
        <filename>isis.properties</filename> file, this is not generally
        recommended. If it is disabled then the
        <methodname>objectChanged()</methodname> method may need to be called
        manually.</para>
      </sect1>
    </chapter>

    <chapter>
      <title>How to handle security concerns</title>

      <abstract>
        <para>Further validation how-to's that apply across all class
        members</para>
      </abstract>

      <para>This chapter has some additional recipes/how-tos relating to
      implementing business rules. They apply across all class members.</para>

      <sect1 id="sec.BusinessRulesForCertainUsersOrRoles">
        <title>Hiding, disabling or validating for specific users or
        roles</title>

        <para>Generally it is not good practice to embed knowledge of roles
        and/or users into the domain classes; instead, this should be the
        responsibility of the framework or platform and should be specified
        and administered externally to the domain model. However, in rare
        circumstances it might be necessary or pragmatic to implement access
        control within the domain model.</para>

        <para>The current user can be obtained from
        <classname>DomainObjectContainer</classname>, using its
        <methodname>getUser()</methodname> method. Alternatively, if the
        domain object inherits from
        <classname>AbstractDomainObject</classname>, then
        <methodname>getUser()</methodname> is also inherited. In either case
        the method returns an object of type
        <methodname>org.apache.isis.security.UserMemento</methodname>, which
        holds both username and the set of roles for that user. The full
        details of the security classes can be found in <xref
        linkend="apx.SecurityClasses" />.</para>

        <para>The mechanism to apply a business rule is just to return an
        appropriate value from a supporting
        <methodname>hideXxx()</methodname>,
        <methodname>disableXxx()</methodname> or
        <methodname>validateXxx()</methodname> method.</para>

        <para>For example, the following requires that the MODIFY_SALARY role
        is assigned to the current user in order to update a salary property
        beyond a certain value:</para>

        <programlisting format="linespecific">public class Employee extends AbstractDomainObject {
    public BigDecimal getSalary() { ... }
    public void setSalary(BigDecimal salary) { ... }
    public String validateSalary() {
        return salary.doubleValue() &gt;= 30000 &amp;&amp;
              !getUser().hasRole("MODIFY_SALARY")?
              "Need MODIFY_SALARY role to increase salary above 30000": null;
    }
}</programlisting>
      </sect1>

      <sect1>
        <title>How to use Isis' authorization manager</title>

        <para>An alternative to hard-coding role names within the domain
        entities is instead to configure an authorization manager. This is a
        component that can either hide or disable access to class members
        (properties, collections, actions).</para>

        <para>The core "bypass" authorization manager simply provides access
        to all class members.</para>

        <para>To enable a different authorization manager, update the
        <code>isis.properties</code> file, for example:</para>

        <programlisting>isis.authorization=file</programlisting>

        <para>Also update the <filename>pom.xml</filename> to reference this
        component, for example:</para>

        <para><programlisting>&lt;properties&gt;
    ...
    &lt;isis-security-file.version&gt;1.0.0-SNAPSHOT&lt;/isis-security-file.version&gt;
&lt;/properties&gt;

&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        ...
        &lt;dependency&gt;
            &lt;groupId&gt;org.apache.isis.security&lt;/groupId&gt;
            &lt;artifactId&gt;isis-security-file&lt;/artifactId&gt;
            &lt;version&gt;${isis-security-file.version}&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;

&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.apache.isis.security&lt;/groupId&gt;
        &lt;artifactId&gt;isis-security-file&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</programlisting></para>

        <para>See the documentation for the chosen authorization manager as to
        how security information should be configured. For example, the
        file-based authorization manager reads from some configuration files
        alongside <filename>isis.properties</filename>.</para>
      </sect1>
    </chapter>

    <chapter id="chp.DomainServices">
      <title>Domain Services, Repositories and Factories</title>

      <abstract>
        <para>How-to's relating to writing services, repositories and
        factories.</para>
      </abstract>

      <para>This chapter contains how-to's for programming conventions that
      writing domain services (by which we also mean repositories and
      factories); ie everything that isn't a domain object or a value
      type.</para>

      <para>Domain services are instantiated once and once only by the
      framework, and are used to centralize any domain logic that does not
      logically belong in a domain entity or value. <emphasis>Isis</emphasis>
      will automatically inject services into every domain entity that
      requests them, and into each other.</para>

      <sect1 id="sec.Services">
        <title>How to register domain services, repositories and
        factories</title>

        <para>All domain services (which includes repositories and factories)
        should be registered in the isis.properties configuration file, under
        the <varname>isis.services.prefix</varname> (a common package name)
        and <varname>isis.services</varname> key (a comma-separated
        list).</para>

        <para>For example:</para>

        <programlisting>isis.services.prefix = org.apache.isis.support.prototype.objstore.dflt
isis.services = employee.EmployeeRepositoryDefault, claim.ClaimRepositoryDefault</programlisting>

        <para>This will instantiate a single instance of each of the two
        services listed.</para>
      </sect1>

      <sect1>
        <title>How to write a typical domain service</title>

        <para>Services consist of a set of logically grouped actions, and as
        such follow the same conventions as for entities (see <xref
        linkend="chp.Actions" />). However, a service cannot have (persisted)
        properties, nor can it have (persisted) collections.</para>

        <para>For convenience you can inherit from
        <classname>AbstractService</classname> or one of its subclasses (see
        <xref linkend="sec.AbstractService" />), but this is not
        mandatory.</para>

        <sect2>
          <title>The <methodname>getId()</methodname> method</title>

          <para>Optionally, a service may provide a
          <methodname>getId()</methodname> method:</para>

          <programlisting>public String getId()</programlisting>

          <para>This method returns a logical identifier for a service,
          independent of its implementation. Currently it used only by
          perspectives, providing a label by which to record the services that
          are available for a current user's profile. See <xref
          linkend="chp.UserProfiles" /> for more about profiles and
          perspectives.</para>
        </sect2>

        <sect2>
          <title>(Suppressing) contributed actions</title>

          <para>Any n-parameter action provided by a service will
          automatically be contributed to the list of actions for each of its
          (entity) parameters. From the viewpoint of the entity the action is
          called a contributed action.</para>

          <para>For example, given a service:</para>

          <programlisting>public interface Library {
    public Loan borrow(Loanable l, Borrower b);
}</programlisting>

          <para>and the entities:</para>

          <programlisting>public class Book implements Loanable { ... }y</programlisting>

          <para>and</para>

          <programlisting>public class LibraryMember implements Borrower { ... }</programlisting>

          <para>then the <methodname>borrow(...)</methodname> action will be
          contributed to both <classname>Book</classname> and to
          <classname>LibraryMember</classname>.</para>

          <para>This is an important capability because it helps to decouple
          the concrete classes from the services.</para>

          <para>If necessary, though, this behaviour can be suppressed by
          annotating the service action with
          <classname>@org.apache.isis.applib.annotations.NotContributed</classname>.</para>

          <para>For example:</para>

          <programlisting>public interface Library {
    @NotContributed
    public Loan borrow(Loanable l, Borrower b);
}</programlisting>

          <para>If annotated at the interface level, then the annotation will
          be inherited by every concrete class. Alternatively the annotation
          can be applied at the implementation class level and only apply to
          that particular implementation.</para>

          <para>Note that an action annotated as being
          <classname>@NotContributed</classname> will still appear in the
          service menu for the service. If an action should neither be
          contributed nor appear in service menu items, then simply annotate
          it as <classname>@Hidden</classname>.</para>
        </sect2>

        <sect2>
          <title>(Suppressing) service menu items</title>

          <para>By default every action of a service (by which we also mean
          repositories and factories) will be rendered in the viewer, eg as a
          menu item for that service menu. This behaviour can be suppressed by
          annotating the action using
          <classname>@org.apache.isis.applib.annotations.NotInServiceMenu</classname>.</para>

          <para>For example:</para>

          <programlisting>public interface Library {
    @NotInServiceMenu
    public Loan borrow(Loanable l, Borrower b);
}</programlisting>

          <para>Note that an action annotated as being
          <classname>@NotInServiceMenu</classname> will still be contributed.
          If an action should neither be contributed nor appear in service
          menu items, then simply annotate it as
          <classname>@Hidden</classname>.</para>

          <para>Alternatively, this can be performed using a supporting
          method:</para>

          <programlisting>public class LibraryImpl implements Library {
    public Loan borrow(Loanable l, Borrower b) { ... }
    public boolean notInServiceMenuBorrow() { ... }
}</programlisting>
        </sect2>

        <sect2>
          <title>(Suppressing) service menus</title>

          <para>If none of the service menu items should appear, then the
          service itself should be annotated as @Hidden.</para>

          <para>For example:</para>

          <programlisting>@Hidden
public interface EmailService {
    public void sendEmail(String to, String from, String subject, String body);
    public void forwardEmail(String to, String from, String subject, String body);
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>How to use a generic repository</title>

        <para>To speed up initial prototype the framework allows so-called
        generic repositories to be defined, one per entity. Such a repository
        will, for its specified type, provide methods to:</para>

        <itemizedlist>
          <listitem>
            <para>Create a new transient instance</para>
          </listitem>

          <listitem>
            <para>Create a new persisted instance</para>
          </listitem>

          <listitem>
            <para>Find all persisted instances</para>
          </listitem>

          <listitem>
            <para>Find instances with a specified title</para>
          </listitem>
        </itemizedlist>

        <para>To register such a service prefix the class name with the prefix
        <literal>repository#</literal>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">isis.services = repository#dom.Booking</programlisting>

        <para>Over time, you should expect most if not all of these generic
        repositories will be replaced with regular repository types (see <xref
        linkend="sec.CustomRepository" />).</para>
      </sect1>

      <sect1 id="sec.CustomRepository">
        <title>How to write a custom repository</title>

        <para>Repositories are defined as interfaces within the domain, and
        their implementation will vary by object store. During prototyping and
        for much of development, you will probably find it easiest to use an
        in-memory object store or perhaps the <acronym>XML</acronym> object
        store, with only a small number of instances. The
        <classname>DomainObjectContainer</classname> provides a set of methods
        that make it easy to pull back all instances from the object store
        which can then be filtered as required. Later on, you can replace the
        implementation depending upon the specifics of the object store that
        you'll be using for production.</para>

        <para>If you inherit from the <literal
        moreinfo="none">org.apache.isis.applib.AbstractFactoryAndRepository</literal>
        adapter class then this will automatically have the
        <classname>DomainObjectContainer</classname> injected, and provides
        convenience methods that delegate to the container. Using this is not
        mandatory, however.</para>

        <para>The methods provided by the
        <classname>DomainObjectContainer</classname> to support repositories
        are:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>allInstances(Class&lt;T&gt;
            ofType)</methodname></para>

            <para>Returns all instances of the specified type. Note that this
            includes all instances of any subtypes.</para>
          </listitem>

          <listitem>
            <para><methodname>allMatches(...)</methodname></para>

            <para>Returns all instances matching the provided
            arguments.</para>
          </listitem>

          <listitem>
            <para><methodname>firstMatch(...)</methodname></para>

            <para>Returns the first instance matching the provided
            arguments.</para>
          </listitem>

          <listitem>
            <para><methodname>uniqueMatch(...)</methodname></para>

            <para>Returns the one-and-only instance matching the provided
            arguments (else is an exception).</para>
          </listitem>
        </itemizedlist>

        <para>The last three methods, <methodname>*Match(...)</methodname> are
        all overloaded in order to return a subset of object instances. Some
        of these are "naive"; all instances are returned from the object
        store, and the filtering is performed within the repository. Others
        are designed to pass the query predicate back to the object store so
        that only the matching rows are returned.</para>

        <para>Each of these options are discussed in more detail below.</para>

        <sect2>
          <title>Finding by Title</title>

          <para>The first version of finding instances is to specify the
          required title for the matching objects:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Class&lt;T&gt; ofType, String
              title)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Class&lt;T&gt; ofType, String
              title)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Class&lt;T&gt; ofType, String
              title)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>Although easy and intuitive, this isn't generally recommended
          for production use because (a) the matching is performed within the
          repository rather than the object store, and (b) the title string
          can often change as business requirements are refined.</para>

          <para>That said, it is possible to eliminate the first disadvantage
          by using the <classname>Query</classname> API, discussed below; this
          provides an implementation that is equivalent to find by
          title.</para>
        </sect2>

        <sect2>
          <title>Finding by Pattern</title>

          <para>The next technique of finding instances is to specify pattern
          object to match against (sometimes called "query-by-example", or
          <acronym>QBE</acronym>):</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Class&lt;T&gt; ofType, Object
              pattern)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Class&lt;T&gt; ofType, Object
              pattern)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Class&lt;T&gt; ofType, Object
              pattern)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>Any non-null value of the pattern object is used as the
          predicate.</para>

          <para>Although more robust that searching by title, this technique
          is also not likely to be valid for production code because the
          matching is still performed within the repository rather than within
          the object store.</para>

          <para>That said, it is possible to eliminate the first disadvantage
          by using the <classname>Query</classname> API, discussed below; this
          provides an implementation that is equivalent to find by
          pattern.</para>

          <note>
            <para>If the pattern object is created using
            <methodname>newTransientInstance(...)</methodname>, then any
            default values for properties will automatically be set (see <xref
            linkend="sec.DefaultPropertyValue" />). If this isn't required,
            they will need to be manually cleared.</para>
          </note>
        </sect2>

        <sect2>
          <title>Finding using the <classname>Filter</classname> API</title>

          <para>The third overloaded version of the matching methods to find
          instances all take an
          <classname>org.apache.isis.applib.Filter&lt;T&gt;</classname>
          instance:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Class&lt;T&gt; ofType,
              Filter&lt;T&gt; filter)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Class&lt;T&gt; ofType,
              Filter&lt;T&gt; filter)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Class&lt;T&gt; ofType,
              Filter&lt;T&gt; filter)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>The <classname>Filter&lt;T&gt;</classname> interface is very
          straightforward:</para>

          <programlisting>public interface Filter&lt;T&gt; {
    public boolean accept(T obj);
}</programlisting>

          <para>Every object of the given type (and subclasses) is passed into
          the <classname>Filter</classname> instance; only those
          <methodname>accept()</methodname>'ed are returned from the
          <methodname>*Match()</methodname> method.</para>

          <para>Although flexible, with this technique the matching is also
          performed within the repository rather than the object store, and so
          is also likely not to be suitable for production use where there are
          many instances of the given type.</para>
        </sect2>

        <sect2>
          <title>Finding using the <classname>Query</classname> API</title>

          <para>The finaly overloaded version of the matching methods take an
          instance of
          <classname>org.apache.isis.applib.query.Query&lt;T&gt;</classname>
          interface:</para>

          <itemizedlist>
            <listitem>
              <para><methodname>allMatches(Query&lt;T&gt;
              query)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>firstMatch(Query&lt;T&gt;
              query)</methodname></para>
            </listitem>

            <listitem>
              <para><methodname>uniqueMatch(Query&lt;T&gt;
              query)</methodname></para>
            </listitem>
          </itemizedlist>

          <para>Unlike all the other matching mechanisms, the point of the
          <classname>Query</classname> interface is for it to be passed back
          to the object store and evaluated there.</para>

          <para>The applib provides several implementations that implement the
          <classname>Query&lt;T&gt;</classname> interface. Probably the most
          important of these is <classname>QueryDefault&lt;T&gt;</classname>,
          which provides a set of factory methods for constructing
          <classname>Query</classname> instances that represent a named query
          with a map of parameter/argument pairs.</para>

          <para>For example:</para>

          <programlisting>public class CustomerRepositoryImpl implements CustomerRepository {
    public List&lt;Customer&gt; findCustomers(
            @Named("Last Name") String lastName,
            @Named("Postcode")  String postCode
        ) {
        QueryDefault&lt;Customer&gt; query = 
            QueryDefault.create(
                Customer.class, 
                "findCustomers", 
                "lastName", lastName, 
                "postCode", postCode);

        return getContainer().allMatches(query);
    }
    ...
}</programlisting>

          <para>Above it was noted that the other overloaded versions of the
          matching <acronym>API</acronym> have the disadvantage that the
          matching is performed within the repository. As an alternative to
          using "find by title" or "find by pattern", you may wish to use
          QueryFindByTitle and QueryFind</para>

          <itemizedlist>
            <listitem>
              <para><classname>QueryFindByTitle&lt;T&gt;</classname>, which
              corresponds to the <methodname>allMatches(...)</methodname> for
              searching by title</para>
            </listitem>

            <listitem>
              <para><classname>QueryFindByPattern&lt;T&gt;</classname>, which
              corresponds to the <methodname>allMatches(...)</methodname> for
              searching by pattern</para>
            </listitem>
          </itemizedlist>

          <para>There is also a
          <classname>QueryFindAllInstances&lt;T&gt;</classname>, which
          corresponds to the <methodname>allInstances()</methodname>
          method.</para>

          <para>The interpretation of a <classname>Query</classname> instance
          ultimately depends on the object store. All object stores will
          support <classname>QueryFindAllInstances</classname>, and most will
          provide a mechanism to support <classname>QueryDefault</classname>.
          Check the object store documentation to determine whether they
          support other <classname>Query</classname> implementations (ie,
          <classname>QueryFindByTitle</classname> and
          <classname>QueryFindByPattern</classname>).</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Factories</title>

        <para>Like repositories, factories are defined by interface in the
        domain, decoupling the domain objects from their actual
        implementation. Unlike repositories, there is no particular need to
        change the implementation when moving from one object store to
        another, because in all cases the factory can simply delegate to its
        injected <classname>DomainObjectContainer</classname>.</para>

        <para>The methods for <classname>DomainObjectContainer</classname>
        that are relevant for a factory are:</para>

        <itemizedlist>
          <listitem>
            <para><methodname>&lt;T&gt; T newTransientInstance(final
            Class&lt;T&gt; ofClass)</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>&lt;T&gt; T newPersistentInstance(final
            Class&lt;T&gt; ofClass)</methodname></para>
          </listitem>

          <listitem>
            <para><methodname>persist(Object)</methodname></para>
          </listitem>
        </itemizedlist>

        <para>These are discussed in more detail in <xref
        linkend="sec.HowToCreateAnObject" />. See also <xref
        linkend="apx.DomainObjectContainer" /> for full coverage of the
        methods available in
        <classname>DomainObjectContainer</classname>.</para>
      </sect1>
    </chapter>

    <chapter id="chp.ValueTypes">
      <title>Value Types</title>

      <abstract>
        <para>Built-in value types, writing your own value types, and
        supporting third-party value types.</para>
      </abstract>

      <para>The state of any given entity is characterized by properties
      (<xref linkend="chp.Properties" />) and collections (<xref
      linkend="chp.Collections" />). A collections is a one-to-many reference
      to another entities, while a property is either a one-to-one reference
      to another entity, or it is a value.</para>

      <para>But what's a value? Well, it's an atomic piece of state. A string
      is a value, so is a number, so is a date. Values should be designed to
      be immutable (though some system value types, such as
      <classname>java.util.Date</classname>, famously are not).</para>

      <para><emphasis>Isis</emphasis> supports all the standard JDK value
      types, and defines a number of its own (eg
      <classname>Percentage</classname> and <classname>Color</classname>). It
      also allows you to define your own value types, such as
      <classname>LastName</classname>, or <classname>Celsius</classname>, or
      <classname>ComplexNumber</classname>.</para>

      <para>Finally, it's also possible to make Isis integrate with
      third-party value types, such as <ulink
      url="http://joda-time.sourceforge.net/">JodaTime</ulink>.</para>

      <para><note>
          <para><emphasis>Isis</emphasis>' support for a particular value type
          does not necessarily imply that there is a custom widget for that
          type in a particular viewer. Rather, it means that the state of the
          object can be serialized, is expected to have equal-by-content
          semantics, and is expected to be immutable. It may also be parseable
          from a string.</para>
        </note></para>

      <sect1>
        <title>Built-in Value Types</title>

        <para>The following are the value types supported by
        <emphasis>Isis</emphasis> out-of-the-box.</para>

        <sect2>
          <title>JDK Types</title>

          <para>The following <acronym>JDK</acronym> types are supported by
          <emphasis>Isis</emphasis>.</para>

          <sect3>
            <title>Primitive Types</title>

            <para>All the primitive types may be used as values:
            <classname>byte</classname>, <classname>short</classname>,
            <classname>int</classname>, <classname>long</classname>,
            <classname>float</classname>, <classname>double</classname>,
            <classname>char</classname>, and
            <classname>boolean</classname>.</para>
          </sect3>

          <sect3>
            <title>Wrapper Types</title>

            <para>The wrapper types for each of the primitives can also be
            used as value types: <classname>java.lang.Byte</classname>,
            <classname>java.lang.Short</classname>,
            <classname>java.lang.Integer</classname>,
            <classname>java.lang.Long</classname>,
            <classname>java.lang.Float</classname>,
            <classname>java.lang.Double</classname>,
            <classname>java.lang.Character</classname>,
            <classname>java.lang.Boolean</classname>.</para>
          </sect3>

          <sect3>
            <title>Java Classes</title>

            <para>The following java classes have value semantics and may be
            used as value types:</para>

            <itemizedlist>
              <listitem>
                <para><classname>java.lang.String</classname></para>
              </listitem>

              <listitem>
                <para><classname>java.math.BigInteger</classname> and
                <classname>java.math.BigDecimal</classname></para>
              </listitem>

              <listitem>
                <para><classname>java.util.Date</classname> (date and time),
                <classname>java.sql.Date</classname> (date only), and
                <classname>java.sql.Time</classname> (time only)</para>
              </listitem>

              <listitem>
                <para><classname>java.sql.Timestamp</classname></para>
              </listitem>

              <listitem>
                <para><classname>java.awt.Image</classname></para>
              </listitem>
            </itemizedlist>
          </sect3>

          <sect3>
            <title>Isis AppLib</title>

            <para><emphasis>Isis</emphasis> itself also provides a number of
            its own value types. These are all in the
            <classname>org.apache.applib.value</classname> package:</para>

            <itemizedlist>
              <listitem>
                <para><classname>Color</classname></para>
              </listitem>

              <listitem>
                <para><classname>Date</classname> (date only),
                <classname>DateTime</classname> (date and time) and
                <classname>Time</classname> (time only)</para>
              </listitem>

              <listitem>
                <para><classname>TimeStamp</classname></para>
              </listitem>

              <listitem>
                <para><classname>Image</classname></para>
              </listitem>

              <listitem>
                <para><classname>Money</classname></para>
              </listitem>

              <listitem>
                <para><classname>Password</classname></para>
              </listitem>

              <listitem>
                <para><classname>Percentage</classname></para>
              </listitem>
            </itemizedlist>
          </sect3>
        </sect2>

        <sect2>
          <title>Value formats</title>

          <para><emphasis>Isis</emphasis> provides default formats for the
          inbuilt value types, according to type. These can be modified using
          <filename>isis.properties</filename>.</para>

          <para>These formats cut across the above categories; for example the
          byte format relates to both <classname>byte</classname> (primitive)
          and <classname>java.lang.Byte</classname> (wrapper). In all cases
          this setting can be overriden for a specific field using the @Mask
          annotation (see <xref linkend="sec.MaskAnnotation" />).</para>

          <sect3>
            <title>Byte format</title>

            <para>The format for all bytes can be set, replacing the default
            format derived from the system, using the following property to
            specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.byte=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Date Format</title>

            <para>The format for all dates can be set, replacing the default
            format derived from the system, using the following property to
            specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.date=dd/MM/yy</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Date/time Format</title>

            <para>The format for all date/time values can be set, replacing
            the default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.datetime=dd/MM/yy</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Decimal format</title>

            <para>The format for <classname>BigDecimal</classname> values can
            be set, replacing the default format derived from the system,
            using the following property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.decimal=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Double format</title>

            <para>The format for all double values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.double=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Float format</title>

            <para>The format for all float values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.float=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Integer format</title>

            <para>The format for all integers (including
            <classname>BigInteger</classname>) can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.int=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Long format</title>

            <para>The format for all long values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.long=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Short format</title>

            <para>The format for all short values can be set, replacing the
            default format derived from the system, using the following
            property to specify a mask:</para>

            <programlisting format="linespecific">isis.value.format.short=####</programlisting>

            <para>The mask is used to set up a
            <classname>java.text.DecimalFormat</classname> formatting object
            so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Time Format</title>

            <para>The format for all time values can be set, replacing the
            default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.time=ddMMyyyy hhmm</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>

          <sect3>
            <title>Timestamp Format</title>

            <para>The format for time stamp values can be set, replacing the
            default format derived from the system, using the following
            property to specify one of <emphasis>long</emphasis>,
            <emphasis>medium</emphasis>, <emphasis>short</emphasis>,
            <emphasis>isolong</emphasis>, <emphasis>isoshort</emphasis> or a
            mask:</para>

            <programlisting format="linespecific">isis.value.format.timestamp=hh:mm</programlisting>

            <para>When a mask is specified it is used to set up a
            <classname>java.text.SimpleDateFormat</classname> formatting
            object so details of the mask format can be found in the Java
            documentation.</para>
          </sect3>
        </sect2>
      </sect1>

      <sect1>
        <title>Custom Value Types</title>

        <para>In addition to the built-in value types it is also possible to
        define user-defined value types. This is typically done using the
        <classname>@Value</classname> annotation.</para>

        <para>The <literal>@Value</literal> annotation is used to provide an
        implementation of the
        <classname>org.apache.isis.applib.adapters.ValueSemanticsProvider</classname>
        interface. In turn this provides objects that allow the framework to
        interact with the value, specifically:</para>

        <itemizedlist>
          <listitem>
            <para>the <classname>EncoderDecoder</classname> is used to convert
            the value into and back out of serializable form</para>

            <para>This is used by some object stores (eg the
            <acronym>XML</acronym> Object Store), for remoting and also by the
            XML Snapshot capability (see <xref
            linkend="chp.XmlSnapshots" />);</para>
          </listitem>

          <listitem>
            <para>the <classname>Parser</classname> is used to convert
            <classname>String</classname>s into the value type</para>

            <para>This is used as a fallback by viewers that do not have any
            specific widgets to support the particular value type, and make do
            with a simple text field instead.</para>

            <para>An obvious example is to parse a date. But it could be used
            to parse "TRUE" and "FALSE" into a boolean (as opposed to using a
            checkbox).</para>
          </listitem>

          <listitem>
            <para>the <classname>DefaultsProvider</classname> is used to
            provide a meaningful default for the value</para>

            <para>Not every value type will have a default, but some do (eg
            false for a boolean, 0 for a number). This is used as the default
            value for non-<classname>@Optional</classname> properties and
            parameters.</para>
          </listitem>
        </itemizedlist>

        <para>Each of these interfaces also reside in
        <classname>org.apache.isis.applib.adapters</classname>.</para>

        <para>For more details, explore the built-in types within the applib,
        for example
        <classname>org.apache.isis.applib.value.Money</classname>.</para>

        <programlisting format="linespecific">@Value(semanticsProviderName = 
         "org.apache.isis.core.progmodel.facets.value.MoneyValueSemanticsProvider")
public class Money extends Magnitude {
    ...
}</programlisting>

        <para>where <classname>MoneyValueSemanticsProvider</classname> is the
        implementation of <classname>ValueSemanticsProvider</classname>
        described above.</para>

        <para><note>
            <para>Using value types generally removes the need for using
            <literal>@MustSatisfy</literal> annotation (see <xref
            linkend="sec.MustSpecify" />); the rules can instead move down
            into a <methodname>validate()</methodname> method on the value
            type itself.</para>
          </note></para>
      </sect1>

      <sect1>
        <title>Third-party Value Types</title>

        <para>Third party value types, such as those in <ulink
        url="http://joda-time.sourceforge.net/">JodaTime</ulink>, can also
        supported, again through the use of a
        <classname>ValueSemanticsProvider</classname>. However, since the
        source code cannot be altered, the provider must be supplied using a
        key value in <methodname>isis.properties</methodname> configuration
        file.</para>

        <para>For example, the following would register a semantics provider
        for <classname>org.jodatime.time.DateTime</classname>:</para>

        <programlisting>isis.core.progmodel.value.org.jodatime.time.DateTime.semanticsProviderName=\
    com.mycompany.values.CalendarIntervalValueSemanticsProvider</programlisting>

        <note>
          <para>At the time of writing <emphasis>Apache Isis</emphasis> does
          not currently ship with any
          <classname>ValueSemanticsProvider</classname>s, though doing so is
          on the roadmap.</para>
        </note>
      </sect1>
    </chapter>
  </part>

  <part id="prt.SupportingFeatures">
    <title>Supporting Features</title>

    <chapter id="chp.Clock">
      <title>Clock</title>

      <abstract>
        <para>The default Clock and alternative implementations.</para>
      </abstract>

      <para>Many if not all enterprise applications deal with dates and times
      in one way or another. For example, if an <classname>Order</classname>
      is placed, then the <classname>Customer</classname> may have 30 days to
      pay the Invoice, otherwise a penalty may be levied. However, this can
      complicate automated testing: "today+30" will be a different date every
      time the test is run.</para>

      <para>A common solution is to require that domain objects do not go
      directly to the system for the current date (ie don't simply instantiate
      a new <classname>java.util.Date</classname> in order to get the current
      time); instead they should call some sort of facade.</para>

      <para>The <emphasis>Apache Isis</emphasis> framework provides such a
      facade through the
      <classname>org.apache.isis.applib.clock.Clock</classname> class. The
      defaults for all values refer back to the <classname>Clock</classname>,
      and - because the <classname>Clock</classname> is a singleton - it is
      easy for any application code to obtain the current time also.</para>

      <para>For example:</para>

      <programlisting>public class Customer {
     public Order placeOrder(Product p) {
         Date now = Clock.getTimeAsDate();
         ...
     }
     ...
}</programlisting>

      <sect1>
        <title>Lazily Instantiated</title>

        <para>The first call to <methodname>Clock.getTime()</methodname> will
        lazily instantiate the singleton, with the default implementation
        being one that simply delegates to the system's internal clock. To use
        a different <classname>Clock</classname> implementation, eg one that
        delegates to an NNTP server, all that is required is to instantiate it
        any time prior to bootstrapping <emphasis>Isis</emphasis>
        itself.</para>

        <para>One notable implementation that notably takes advantage of this
        is <classname>FixtureClock</classname>, used for testing. See <xref
        linkend="chp.Fixtures" /> for more information.</para>
      </sect1>

      <sect1>
        <title>Possibly Replaceable</title>

        <para>Clock implementations can indicate whether they are replaceable
        as the singleton, or not.</para>

        <para>Most (all?) production implementations (eg the default system
        clock) are <emphasis>not</emphasis> replaceable; once instantiated,
        any attempt to instantiate another subclass will be rejected with an
        exception.</para>

        <para>However implementations to work with tests (such as
        <classname>FixtureClock</classname>, already mentioned) are more
        likely to be replaceable, so that they can be setup multiple times as
        required.</para>
      </sect1>
    </chapter>

    <chapter id="chp.UserProfiles">
      <title>Profiles</title>

      <abstract>
        <para>Support for user profiles</para>
      </abstract>

      <para>As well as allowing domain entities to be persisted into object
      stores, <emphasis>Apache Isis</emphasis> also allows user
      <emphasis>profiles</emphasis> to be persisted into a profile
      store.</para>

      <sect1>
        <title>Profiles and Perspectives</title>

        <para>Every user can have one profile associated with them, which
        consists of:</para>

        <itemizedlist>
          <listitem>
            <para>a set of options or preferences</para>
          </listitem>

          <listitem>
            <para>a set of perspectives</para>
          </listitem>
        </itemizedlist>

        <para>A perspective is something akin to a layout or desktop,
        representing a configuration of relevant objects as might be displayed
        on the home page of the viewer. In particular, perspectives allow the
        set of services available to a user (eg as icons in the
        <acronym>DnD</acronym> viewer) to be customized for that user. Since
        these services represent the "start points" for the user to interact
        with the domain model, they in a sense define an application on a
        per-user basis.</para>

        <para>The elements that make up a perspective are:</para>

        <itemizedlist>
          <listitem>
            <para>a set of services (identified by the string returned from
            each service's <methodname>getId()</methodname> method, see <xref
            linkend="chp.DomainServices" />)</para>

            <para>These are the services (eg icons) that can be accessed from
            that perspective</para>
          </listitem>

          <listitem>
            <para>a set of objects</para>

            <para>These might represent bookmarks to objects saved from a
            previous session.</para>
          </listitem>
        </itemizedlist>

        <para>The applib contains types to define these two concepts;
        specifically <classname>Profile</classname> and
        <classname>Perspective</classname>. These are actually interfaces, the
        implementation is provided by framework itself.</para>
      </sect1>

      <sect1>
        <title>Runtime and Viewer Support</title>

        <para>Support for profiles will vary across runtime implementations
        and across viewers. The <emphasis>default runtime</emphasis>
        implementation <emphasis>does</emphasis> support profiles, however,
        and works such that if a user logs in and no perspective exists for
        that user one will automatically be created. This will either be a
        copy of the 'template' perspective, or, if no such template exists,
        then simply a perspective containing all the known services.</para>

        <para>Moreover, the runtime must be configured to use some sort of
        persistence mechanism for profiles such that they are persisted
        between runs. The default runtime does support this (though the
        default is the in-memory profilestore that does not persist any
        information between sessions).</para>

        <para>Even if the configured runtime does support profiles, not every
        viewer necessarily uses the concept. The most notable viewer that
        <emphasis>does</emphasis> support the idea is the <emphasis>dnd
        viewer</emphasis>.</para>
      </sect1>
    </chapter>

    <chapter id="chp.Fixtures">
      <title>Fixtures and SwitchUser</title>

      <abstract>
        <para>Using fixtures to setup the system, generally for testing
        purposes.</para>
      </abstract>

      <para>Fixtures are used to setup the framework into a known state. This
      is predominantly done for testing, and in particular when running with
      the in-memory object store. However, fixtures can also be used to
      specify the user that has "logged on", and to set the clock.</para>

      <para>Whether a fixture has any effect will depend on several
      factors:</para>

      <itemizedlist>
        <listitem>
          <para>the first is the <classname>DeploymentType</classname>;
          specifying the logged on user will only be honoured if running in
          exploration mode (or more precisely, where
          <methodname>DeploymentType#isExploring()</methodname> returns
          true);</para>
        </listitem>

        <listitem>
          <para>the second is the object store; most persistent object stores
          will either ignore fixtures, or only allow them to be installed once
          or if run with an (object store-specific) flag set</para>
        </listitem>
      </itemizedlist>

      <sect1 id="sec.HowToRegisterFixtures">
        <title>How to register fixtures</title>

        <para>All domain services (which includes repositories and factories)
        should be registered in the <emphasis>isis.properties</emphasis>
        configuration file, under the <varname>isis.fixtures.prefix</varname>
        and <varname>isis.fixtures</varname> keys.</para>

        <para>For example:</para>

        <programlisting>isis.fixtures.prefix= org.apache.isis.support.prototype.fixture
isis.fixtures= ClaimsFixture,LogOnAsCliveFixture</programlisting>

        <para>It is also possible to specify fixtures from the command line,
        using the --fixture flag.</para>
      </sect1>

      <sect1>
        <title>How to write custom fixtures</title>

        <para>The applib defines several interfaces and classes for writing
        fixtures. The following UML diagram shows their relationships:</para>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Fixtures.png" scale="65" />
          </imageobject>
        </mediaobject>

        <sect2>
          <title><classname>InstallableFixture</classname> and
          <classname>FixtureType</classname></title>

          <para>The <classname>InstallableFixture</classname> interface
          defines the general contract between a fixture and the framework:
          the <classname>FixtureType</classname>, and an
          <methodname>install()</methodname> method.</para>

          <para>The <classname>FixtureType</classname> is used to characterize
          whether the fixture:</para>

          <itemizedlist>
            <listitem>
              <para>if <classname>FixtureType.DOMAIN_OBJECTS</classname> (the
              default), then the fixture will be installed only so long as the
              configured object store does not indicate that fixtures have
              already been installed</para>
            </listitem>

            <listitem>
              <para>if <classname>FixtureType.USER_PROFILES</classname>, then
              the fixture will be installed only so long as the configured
              profile store does not indicate that fixtures have already been
              installed</para>
            </listitem>

            <listitem>
              <para>if <classname>FixtureType.OTHER</classname>, then the
              fixture will always be installed. This usually refers to setting
              the clock or user.</para>
            </listitem>
          </itemizedlist>
        </sect2>

        <sect2>
          <title><classname>BaseFixture</classname> and
          <classname>AbstractFixture</classname></title>

          <para>The <classname>BaseFixture</classname> class is not API, but
          is responsible for instantiating
          <classname>FixtureClock</classname>. This is an implementation of
          <classname>Clock</classname> singleton, which (as described in <xref
          linkend="chp.Clock" />), is used by the rest of the
          <emphasis>Isis</emphasis> framework delegates to in order to obtain
          the current time. The <classname>FixtureClock</classname>'s purpose
          is to allow the current date/time to be set by other
          fixtures.</para>

          <para>The <classname>AbstractFixture</classname> class (inheriting
          from <classname>BaseFixture</classname>) is an general-purpose
          adapter for writing fixtures. It implements
          <classname>CompositeFixture</classname> interface, meaning that
          hierarchies of fixtures can be created following the composite
          design pattern. It also provides a number of convenience
          methods:</para>

          <itemizedlist>
            <listitem>
              <para>the <methodname>setDate(...)</methodname> and
              <methodname>setTime(...)</methodname> method allow the date/time
              to be set.</para>

              <para>This is done using by obtaining the
              <classname>FixtureClock</classname> (from
              <classname>BaseFixture</classname>). There are also some
              convenience methods to move the date/time either earlier or
              later.</para>
            </listitem>

            <listitem>
              <para>the <methodname>switchUser(...)</methodname> method allow
              the logged-on user to be changed</para>

              <para>This changes the user logged-on while the fixtures are
              being installed. This is to facilitate tests that have complex
              setup requirements, eg verifying workflow between different user
              roles.</para>
            </listitem>
          </itemizedlist>

          <para>An alternative to using
          <methodname>setDate(...)</methodname>/<methodname>setTime(...)</methodname>
          is to use <classname>DateFixture</classname>, and an alternative to
          using <methodname>switchUser(...)</methodname> is to use
          <classname>SwitchUserFixture</classname>. Which you use is largely a
          matter of personal preference.</para>
        </sect2>

        <sect2>
          <title><methodname>DateFixture</methodname></title>

          <para>The <classname>DateFixture</classname> provides an alternative
          to <classname>AbstractFixture</classname>, just allowing the current
          date/time to be set.</para>

          <para>The main difference is one of style;
          <classname>DateFixture</classname> can be used in a declarative way,
          whereas <classname>AbstractFixture</classname> is more imperative.
          For example:</para>

          <programlisting>public class DateIs13Jan2007Fixture extends DateFixture {
    public DateIs13Jan2007Fixture() {
        super(2007,1,13);
    }
}</programlisting>

          <para>A fixture in this style could then be used within a composite
          fixture hierarchy.</para>
        </sect2>

        <sect2>
          <title><methodname>SwitchUserFixture</methodname></title>

          <para>The <classname>SwitchUserFixture</classname> provides an
          alternative to <classname>AbstractFixture</classname>, just allowing
          the current user to be switched.</para>

          <para>The main difference is one of style;
          <classname>SwitchUserFixture</classname> can be used in a
          declarative way, whereas <classname>AbstractFixture</classname> is
          more imperative. For example:</para>

          <programlisting>public class SwitchToFrankSupervisorFixture extends SwitchUserFixture {
    public SwitchToFrankSupervisorFixture() {
        super("frank", "user", "supervisor");
    }
}</programlisting>

          <para>A fixture in this style could then be used within a composite
          fixture hierarchy.</para>

          <warning>
            <para>Do be aware of when you call switchUser() in a
            <classname>Fixture</classname> as it causes the current
            transaction to be ended and a new one started (for the new user).
            If you share a reference between the two you will get an
            exception.</para>

            <para>For example:</para>

            <programlisting>Account account = accounts.createAccount(
    "ACME", "Peter Planner", "pplanner@acme.com");
Participant peterPlanner = account.getAdmin();
        
switchUser("pplanner@acme.com", new String[0]);

Work work = plan1.createWork();
BcpPlan plan = (BcpPlan) work.getTarget();
plan.getOwner().modifyLeader(peterPlanner);</programlisting>

            <para>This will fail because <varname>peterPlanner</varname>
            reference is no longer valid after the switch user.</para>

            <para>The solution is to retrieve the object again so it is part
            of the second transaction. In this example we can change to code
            to this:</para>

            <programlisting>accounts.createAccount("ACME", "Peter Planner", "pplanner@acme.com");
        
switchUser("pplanner@acme.com", new String[0]);

Account account = uniqueMatch(Account.class, "0 ACME");
Participant peterPlanner = account.getAdmin();

Work work = plan1.createWork();
BcpPlan plan = (BcpPlan) work.getTarget();
plan.getOwner().modifyLeader(peterPlanner);
</programlisting>
          </warning>
        </sect2>

        <sect2>
          <title><classname>LogonFixture</classname></title>

          <para>Unlike the very similar
          <classname>SwitchUserFixture</classname>, this fixture does not
          affect the currently logged on user while the fixtures are being
          installed. Instead, it is used to specify the user to logon as once
          all the fixtures have been installed.</para>

          <para>If more than one <classname>LogonFixture</classname> is
          specified, the last one encountered is used.</para>
        </sect2>

        <sect2>
          <title><classname>UserProfileFixture</classname></title>

          <para>The <classname>UserProfileFixture</classname> is used to
          populate the configured profile store<footnote>
              <para>A profile store is a persistence mechanism provided by the
              configured runtime that allows user profiles to be stored
              between runs. It is similar to, but independent of, an object
              store (which stores the domain objects themselves).</para>
            </footnote> with user profiles (the concept of which is described
          in <xref linkend="chp.UserProfiles" />).</para>

          <para>To create a user profile for a specific user, inherit from
          <classname>UserProfileFixture</classname>, use the inherited
          <methodname>newUserProfile()</methodname> to create a profile and
          use the inherited <methodname>saveForUser(...)</methodname> method
          to save that profile.</para>

          <para>It is also possible to create a 'template' perspective using
          the <methodname>saveAsDefault(...)</methodname> method. This is used
          as the basis for any new perspectives that are automatically
          created, eg for users who are logging in and for whom there is no
          perspective in existence.</para>

          <para>For example:</para>

          <programlisting>public class PerspectivesFixture extends UserProfileFixture {
  @Override
  protected void installProfiles() {
    Profile profile = newUserProfile();
    Perspective perspective = profile.newPerspective("ECS");
    perspective.addToServices(LocationFactory.class);
    perspective.addToServices(CustomerRepository.class);
    perspective.addToServices(PaymentMethodFactory.class);
        
    saveAsDefault(profile);
  }
}</programlisting>

          <para>With that set up, when a new user now logs in they will see
          three service icons on the screen for locations, customers and
          payment methods. In the <emphasis>dnd viewer</emphasis> the user
          will be able to add and remove services from their perspective. See
          the DnD Viewer documentation for further details.</para>

          <para>Any fixtures, if specified, are only ever loaded once; the
          fixture installer checks with
          <methodname>UserProfileSevice.isInitialized()</methodname> to see if
          the fixture is already installed. This allows fixtures to be used
          for seeding a persisting profile store, and then be ignored
          thereafter.</para>
        </sect2>
      </sect1>
    </chapter>

    <chapter id="chp.XmlSnapshots">
      <title>XML Snapshots</title>

      <abstract>
        <para>Generating <acronym>XML</acronym> snapshots from domain
        objects.</para>
      </abstract>

      <para>The <emphasis>Apache Isis</emphasis> framework provides the
      capability to generate <acronym>XML</acronym> snapshots (and if required
      corresponding <acronym>XSD</acronym> schemas) based on graphs of domain
      objects. This is done using the
      <classname>org.apache.isis.core.runtime.snapshot.XmlSnapshot</classname>
      class.</para>

      <sect1>
        <title>Generating an XML Snapshot</title>

        <para>The <classname>XmlSnapshot</classname> can be created either
        directly or using a builder.</para>

        <sect2>
          <title>Basic Usage</title>

          <para>The standard usage is to instantiate directly.</para>

          <programlisting>XmlSnapshot snapshot = new XmlSnapshot(customer);
Element customerAsXml = snapshot.getXmlElement();</programlisting>

          <para>This will return the <classname>Customer</classname>'s fields,
          titles of simple references, number of items in collections.</para>

          <para>In order to use the <classname>XmlSnapshot</classname>, the
          domain object must implement
          <classname>org.apache.isis.applib.snapshot.Snapshottable</classname>.
          This is just a marker interface.</para>
        </sect2>

        <sect2>
          <title>Including other Elements</title>

          <para>It's also possible to instruct the
          <classname>XmlSnapshot</classname> to "walk" the object graph and
          include other information within the generated
          <acronym>XML</acronym>.</para>

          <para>For example:</para>

          <programlisting>XmlSnapshot snapshot = new XmlSnapshot(customer);
snapshot.include("placeOfBirth");   // (1)
snapshot.include("orders/product"); // (2)
Element customerAsXml = snapshot.getXmlElement();</programlisting>

          <para>In (1), we indicate that we want to also navigate to another
          domain object represented by simple reference "placeOfBirth"; in
          (2), we indicate that we want to navigate the "orders" collection
          (presumably of <classname>Order</classname>s) and for each
          referenced <classname>Order</classname>, to navigate in turn its
          "product" reference (presumably to a <classname>Product</classname>
          class).</para>

          <para>Note that <classname>XmlSnapshot</classname> is mutable, in
          that calls to its <methodname>getXmlElement()</methodname> may
          return different <acronym>XML</acronym> structures based on whether
          additional paths have been <methodname>include()</methodname>'d, or
          whether the state of the domain objects themselves have
          changed.</para>
        </sect2>
      </sect1>

      <sect1>
        <title>Using the Fluent API</title>

        <para>An <classname>XmlSnapshot</classname> can also be constructed
        using an alternative "fluent" API:</para>

        <programlisting>XmlSnapshot snapshot = 
     XmlSnapshot.create(customer)
                .includePath("placeOfBirth")
                .include("orders/product")
                .build();
Element customerAsXml = snapshot.getXmlElement();</programlisting>
      </sect1>

      <sect1>
        <title>The <classname>SnapshottableWithInclusions</classname>
        interface</title>

        <para>As already mentioned, in order to be snapshotted a domain object
        must implement the <classname>Snapshot</classname> interface. This is
        just a marker interface, so implementing it is trivial.</para>

        <para>Alternatively, the domain object can choose to implement the
        sub-interface, <classname>SnapshottableWithInclusions</classname>.
        This moves the responsibility for determining what is included within
        the snapshot from the caller to the snapshottable object
        itself:</para>

        <programlisting>public interface SnapshottableWithInclusions extends Snapshottable {
    List&lt;String&gt; snapshotInclusions();
}</programlisting>

        <para>If necessary, both approaches can be combined.</para>
      </sect1>

      <sect1>
        <title>Generating an XSD schema</title>

        <para>As well as obtaining the XML snapshot, it is also possible to
        obtain an XSD schema that the XML snapshot conforms to.</para>

        <programlisting>XmlSnapshot snapshot = ...;
Element customerAsXml = snapshot.getXmlElement();
Element customerXsd = snapshot.getXsdElement();</programlisting>

        <para>This can be useful for some tools. Note that for the
        <acronym>XSD</acronym> to be correct, the object being snapshotted
        must have non-null values for the paths that are
        <methodname>include()</methodname>'d. If this isn't done then the XSD
        will not be correct reflect for another snapshotted object that does
        have non-null values.</para>
      </sect1>

      <sect1>
        <title>Hints and Tips</title>

        <para>As an alternative to using include(), you might consider
        building a non-persisted domain object (a "view model") which can
        reference only the relevant information required for the
        snapshot.</para>

        <para>For example, if only the 5 most recent
        <classname>Order</classname>s for a <classname>Customer</classname>
        were required, a <classname>CustomerAndRecentOrders</classname> view
        model could hold a collection of just those 5
        <classname>Order</classname>s.</para>

        <para>Typically such view models would implement
        <classname>SnapshottableWithInclusions</classname>.</para>
      </sect1>
    </chapter>
  </part>

  <part id="prt.ReferenceAppendices">
    <title>Reference Appendices</title>

    <appendix>
      <title>Recognized Methods and Prefixes</title>

      <para>The following table lists all of the methods or method prefixes
      that are recognized by <emphasis>Apache Isis</emphasis>' default
      programming model:</para>

      <table>
        <title>Recognized Method Prefixes</title>

        <tgroup cols="7">
          <colspec align="center" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec />

          <thead>
            <row>
              <entry align="center">Prefix</entry>

              <entry align="center">object</entry>

              <entry align="center">property</entry>

              <entry align="center">collection</entry>

              <entry align="center">action</entry>

              <entry align="center">action param</entry>

              <entry align="center">See also</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>addTo</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>removeFrom</entry>
            </row>

            <row>
              <entry>choices</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>
            </row>

            <row>
              <entry>clear</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>modify</entry>
            </row>

            <row>
              <entry>created</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>default</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>
            </row>

            <row>
              <entry>disable</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>get</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>set</entry>
            </row>

            <row>
              <entry>getId</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>(services only)</entry>
            </row>

            <row>
              <entry>hide</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>iconName</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>loaded</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>loading</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>modify</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry>clear</entry>
            </row>

            <row>
              <entry>persisted</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>persisting</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>removing</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>removed</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>removeFrom</entry>

              <entry></entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>addTo</entry>
            </row>

            <row>
              <entry>set</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry>get</entry>
            </row>

            <row>
              <entry>toString</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>title</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>updating</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>updated</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>validate</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry>Y</entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>There are also a number of deprecated methods:</para>

      <table>
        <title>Deprecated Method Prefixes</title>

        <tgroup cols="7">
          <colspec align="center" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec align="center" colwidth="50" />

          <colspec />

          <colspec />

          <thead>
            <row>
              <entry align="center">Prefix</entry>

              <entry align="center">object</entry>

              <entry align="center">property</entry>

              <entry align="center">collection</entry>

              <entry align="center">action</entry>

              <entry align="center">action param</entry>

              <entry align="center">See also</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>deleted</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>deleting</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>saved</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>saving</entry>

              <entry>Y</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>In order to be recognized, all methods must be
      <code>public</code>. Any methods that do not match are deemed to be
      action methods that the user can invoke from the user interface.</para>
    </appendix>

    <appendix>
      <title>Recognized Annotations</title>

      <abstract>
        <para>All the annotations recognized in the <emphasis>Apache
        Isis</emphasis> default programming model.</para>
      </abstract>

      <para>This chapter defines the set of annotations that are recognised by
      the <emphasis>Apache Isis</emphasis> default programming model.</para>

      <sect1>
        <title>@ActionOrder</title>

        <note>
          <para>The recommended mechanism for specifying the order in which
          actions are listed to the user is <code>@MemberOrder</code> (see
          <xref linkend="sec.MemberOrderAnnotation" />)</para>
        </note>

        <para><code>@ActionOrder</code> provides a mechanism to specify the
        order in which actions appear in the user interface, in which the
        order is specified in one place in the class.</para>

        <para>For example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@ActionOrder("PlaceNewOrder, CheckCredit")</emphasis>
public class Customer {

    public Order placeNewOrder() {}

    public CreditRating checkCredit() {}

...
}</programlisting>

        <para>The action names are not case sensitive.</para>

        <para>Compared to <classname>@MemberOrder</classname>, there is
        (currently) one additional advantage in that you can easily specify
        groupings (which may be rendered by the viewer as sub-menus). This
        information may be used by the viewing mechanism to render actions
        into sub-menus.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@ActionOrder("(Account Management: PlaceOrder, CheckCredit), (Personal Details: ChangeOfAddress, AddEmail)")
public class Customer {
    public CreditRating checkCredit() { ... }
    public void changeOfAddress() { ... }
    public Order placeNewOrder() { ... }
    public void addEmail(String emailAddress) { ... }
    ...
}</programlisting>

        <para>However, <code>@ActionOrder</code> is more 'brittle' to change:
        if you change the name of an existing action you will need to ensure
        that the corresponding name within the <code>@ActionOrder</code>
        annotation is also changed.</para>
      </sect1>

      <sect1>
        <title>@ActionSemantics</title>

        <para>This annotation, which applies only to actions, describes
        whether the invocation is safe (as no side-effects), is idempotent
        (may have side-effects but always has the same postconditions), or is
        neither safe nor idempotent. If the annotation is missing then the
        framework assumes non-idempotent.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    @ActionSemantics(Of.SAFE)
    public CreditRating checkCredit() { ... }

    @ActionSemantics(Of.IDEMPOTENT)
    public void changeOfAddress(Address address) { ... }

    @ActionSemantics(Of.NON_IDEMPOTENT)
    public Order placeNewOrder() { ... }
    ...
}</programlisting>

        <para>The annotation was introduced for the restfulobjects viewer in
        order that action invocations could be made available using either
        <acronym>HTTP</acronym> <acronym>GET</acronym>, <acronym>PUT</acronym>
        or <acronym>POST</acronym> (respectively). It is now also used in core
        runtime's in-built concurrency checking; the invocation of a safe
        action does not perform a concurrency check, whereas non-safe actions
        do perform a concurrency check.</para>
      </sect1>

      <sect1>
        <title>@Audited</title>

        <para>This annotation, which applies only to objects, indicates that
        if the object is modified, then it should be submitted to the
        <code>AuditingService</code>, if one has been configured.</para>

        <para>For example:</para>

        <programlisting>@Audited
public class Customer extends AbstractDomainObject {
   ....
}</programlisting>

        <para>The <code>AuditingService</code> is defined within the applib
        (in the <code>org.apache.isis.applib.services.audit</code>
        package):</para>

        <programlisting>public interface AuditingService {
    @Hidden
    public void audit(String user, long currentTimestampEpoch, String objectType, String identifier, String preValue, String postValue);
}</programlisting>

        <para>At the time of writing only the JDO Object Store supported this
        annotation. Check with the documentation of the object store or ask on
        the mailing list to determine whether auditing is supported.</para>
      </sect1>

      <sect1>
        <title>@AutoComplete</title>

        <para>This annotation is to support an auto-complete capability for
        reference properties and action parameters, the idea being that the
        user enters a few characters to locate a reference, and these are
        shown - for example - in a drop-down list box.</para>

        <para>The annotation is specified on the type, and specifies an action
        on a repository; this action should take a single string and should
        return a list of the type.</para>

        <para>For example:</para>

        <programlisting>@AutoComplete(repository=Customers.class, action="autoComplete")
public class Customer extends AbstractDomainObject {
   ....
}</programlisting>

        <para>where:</para>

        <programlisting>public interface Customers {

    @Hidden
    List&lt;Customer&gt; autoComplete(String search);
    ...
}</programlisting>

        <para>This annotation was first implemented in the Wicket
        viewer.</para>
      </sect1>

      <sect1>
        <title>@Aggregated</title>

        <para>This annotation indicates that the object is aggregated, or
        wholly owned, by a root object. This information is of use by some
        object stores implementations (to store the aggregated objects
        "inline"). At the time of writing none of the viewers exploit this
        information, though this may change in the future. (For example, the
        <acronym>DnD</acronym> viewer could be enhanced to prevent aggregated
        objects from being "dragged out" from their root object).</para>

        <para>All value types and all collections are automatically
        aggregated.</para>

        <warning>
          <para>Outside of value types and collections, the
          <classname>@Aggregated</classname> semantics are not completely
          well-defined and so its use is currently discouraged.</para>
        </warning>
      </sect1>

      <sect1>
        <title>@Bounded</title>

        <para>For immutable objects where there is a bounded set of instances,
        the <literal moreinfo="none">@Bounded</literal> annotation can be
        used.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@Bounded
public class County {
    ...
}</programlisting>

        <para>The number of instances is expected to be small enough that all
        instance can be held in memory. The viewer will use this information
        to render all the instances of this class in a drop-down list or
        equivalent.</para>

        <note>
          <para>Although this is not enforced, <literal
          moreinfo="none">@Bounded</literal> is intended for use on <literal
          moreinfo="none">final</literal> classes. Its behaviour when used on
          interfaces, or classes with sub-classes is not specified</para>
        </note>
      </sect1>

      <sect1>
        <title>@Bulk</title>

        <para>For actions that should only be applied to a collection of
        objects of the same type, annotate using
        @<classname>Bulk</classname>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class ToDoItem {
    ...
    @Bulk
    public void markAsCompleted() {
        setCompleted(true);
    }
}</programlisting>

        <para>Bulk actions cannot take arguments, nor can they be hidden,
        disabled or have validation rules.</para>
      </sect1>

      <sect1 id="sec.DebugAnnotation">
        <title>@Debug</title>

        <para>The <classname>@Debug</classname> annotation marks an action
        method as available in debug mode only, and so will not normally be
        displayed by the user interface.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeNewOrder() { ... }
    @Debug
    public List&lt;Order&gt; listRecentOrders() { ... }
    ...
}</programlisting>

        <para>The exact means to access <classname>@Debug</classname> actions
        depends on the viewer.</para>
      </sect1>

      <sect1>
        <title>@Defaulted</title>

        <para>The concept of "defaulted" means being able to provide a default
        value for the type by way of the
        <classname>org.apache.isis.applib.adapters.DefaultsProvider</classname>
        interface. Generally this only applies to value types, where the
        <classname>@Value</classname> annotation (see <xref
        linkend="sec.ValueAnnotation" />) implies encodability through the
        <classname>ValueSemanticsProvider</classname> interface (see <xref
        linkend="chp.ValueTypes" />).</para>

        <para>For these reasons the <classname>@Defaulted</classname>
        annotation is generally never applied directly, but can be thought of
        as a placeholder for future enhancements whereby non-value types might
        also have a default value provided for them.</para>
      </sect1>

      <sect1>
        <title>@DescribedAs</title>

        <para>The <literal moreinfo="none">@DescribedAs</literal> annotation
        is used to provide a short description of something that features on
        the user interface. How this description is used will depend upon the
        viewing mechanism - but it may be thought of as being like a 'tool
        tip'.</para>

        <para>Descriptions may be provided for objects, members (properties,
        collections and actions), and for individual parameters within an
        action method. <literal moreinfo="none">@DescribedAs</literal>
        therefore works in a very similar manner to <literal
        moreinfo="none">@Named</literal> (see <xref
        linkend="sec.NamedAnnotation" />).</para>

        <sect2>
          <title>Providing a description for an object</title>

          <para>To provide a description for an object, use the <literal
          moreinfo="none">@DescribedAs</literal> annotation immediately before
          the declaration of that object class.</para>

          <para>For example:</para>

          <programlisting format="linespecific">@DescribedAs("A customer who may have originally become known to us via " +
             "the marketing system or who may have contacted us directly.")
public class ProspectiveSale {
   ...
}</programlisting>
        </sect2>

        <sect2>
          <title>Providing a description for an object member</title>

          <para>Any member (property, collection or action) may provide a
          description. To specify this description, use the <literal
          moreinfo="none">@DescribedAs</literal> annotation immediately before
          the declaration of that member.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    @DescribedAs("The name that the customer has indicated that they wish to be " +
                 "addressed as (e.g. Johnny rather than Jonathan)")
    public String getFirstName() { ... }
}</programlisting>
        </sect2>

        <sect2>
          <title>Providing a description for an action parameter</title>

          <para>To provide a description for an individual action parameter,
          use the <literal moreinfo="none">@DescribedAs</literal> annotation
          in-line i.e. immediately before the parameter declaration.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
                      Product product,
                      @Named("Quantity")
                      @DescribedAs("The quantity of the product being ordered")
                      int quantity) {
        Order order = createTransientInstance(Order.class);
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>@Disabled</title>

        <para>The <literal moreinfo="none">@Disabled</literal> annotation
        means that the member cannot be used in any instance of the class.
        When applied to the property it means that the user may not modify the
        value of that property (though it may still be modified
        programmatically). When applied to an action method, it means that the
        user cannot invoke that method.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    @Disabled
    public void assessCreditWorthiness() { ... }

    @Disabled
    public int getInitialCreditRating(){ ... }
    public void setInitialCreditRating(int initialCreditRating) { ... }
}</programlisting>

        <para>Note that if an action is marked as <literal
        moreinfo="none">@Disabled</literal>, it will be shown on the user
        interface but cannot ever be invoked. The only possible reason we can
        think to do this is during prototyping, to indicate an action that is
        still to be developed. If a method is intended for programmatic use,
        but not intended ever to be invoked directly by a user, then it should
        be marked as <literal moreinfo="none">@Hidden</literal>
        instead.</para>

        <para>This annotation can also take two parameter indicating where (in
        the UI) it is to be disabled, and when (in the object's lifecycle) it
        is to be disabled. For example:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>(when=When.UNTIL_PERSISTED)
    public void assessCreditWorthiness() { ... }
}</programlisting>

        <para>would disable the action until the object has been saved.
        And:</para>

        <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Disabled</emphasis>(where=Where.PARENTED_TABLES)
    public void getFirstName() { ... }
}</programlisting>

        <para>would disable the property in parented tables but not in regular
        object forms (though note: this would only be used by viewers that
        provide in-table editing capability).</para>

        <para>The acceptable values for the <varname>where</varname> parameter
        are:</para>

        <itemizedlist>
          <listitem>
            <para><code>Where.ANYWHERE</code></para>

            <para>The member should be disabled everywhere.</para>
          </listitem>

          <listitem>
            <para><code>Where.OBJECT_FORMS</code></para>

            <para>The member should be disabled when displayed within an
            object form. For most viewers, this applies to property and
            collection members, not actions.</para>
          </listitem>

          <listitem>
            <para><code>Where.PARENTED_TABLES</code></para>

            <para>The member should be disabled when displayed as a column of
            a table within a parent object's collection. For most (all?)
            viewers, this will have meaning only if applied to a property
            member.</para>
          </listitem>

          <listitem>
            <para><code>Where.STANDALONE_TABLES</code></para>

            <para>The member should be disabled when displayed as a column of
            a table showing a standalone list of objects, for example as
            returned by a repository query. For most (all?) viewers, this will
            have meaning only if applied to a property member.</para>
          </listitem>

          <listitem>
            <para><code>Where.ALL_TABLES</code></para>

            <para>The member should be disabled when displayed as a column of
            a table, either an object's * collection or a standalone list.
            This combines PARENTED_TABLE} and STANDALONE_TABLE</para>
          </listitem>

          <listitem>
            <para><code>Where.NOWHERE</code></para>

            <para>Has no meaning for the <classname>@Disabled</classname>
            annotation (though is used by the <classname>@Hidden</classname>
            annotation, see <xref linkend="sec.HiddenAnnotation" />).</para>
          </listitem>
        </itemizedlist>

        <para>The acceptable values for the <varname>when</varname> parameter
        are:</para>

        <itemizedlist>
          <listitem>
            <para><code>When.ALWAYS</code></para>

            <para>The member should be disabled at all times.</para>
          </listitem>

          <listitem>
            <para><code>When.NEVER</code></para>

            <para>The member should never be disabled (unless disabled through
            some other mechanism, for example an imperative
            <methodname>disableXxx()</methodname> supporting method)..</para>
          </listitem>

          <listitem>
            <para><code>When.ONCE_PERSISTED</code></para>

            <para>The member should be enabled for transient objects, but
            disabled for persisted objects.</para>
          </listitem>

          <listitem>
            <para><code>When.UNTIL_PERSISTED</code></para>

            <para>The member should be disabled for transient objects, but
            enabled for persisted objects.</para>
          </listitem>
        </itemizedlist>

        <para>By default the annotated property or action is always disabled
        (ie defaults to <classname>Where.ANYWHERE</classname>,
        <classname>When.ALWAYS</classname>).</para>
      </sect1>

      <sect1>
        <title>@Encodable</title>

        <para>Encodability means the ability to convert an object to-and-from
        a string, by way of the
        <classname>org.apache.isis.applib.adapters.EncoderDecoder</classname>
        interface. Generally this only applies to value types, where the
        <classname>@Value</classname> annotation (see <xref
        linkend="sec.ValueAnnotation" />) implies encodability through the
        <classname>ValueSemanticsProvider</classname> interface (see <xref
        linkend="chp.ValueTypes" />).</para>

        <para>For these reasons the <classname>@Encodable</classname>
        annotation is generally never applied directly, but can be thought of
        as a placeholder for future enhancements whereby non-value types might
        also be directly encoded.</para>
      </sect1>

      <sect1>
        <title>@EqualByContent</title>

        <para>Equal-by-content is a characteristic of value types, and is
        implied by any class annotated with the the
        <classname>@Value</classname> annotation (see <xref
        linkend="sec.ValueAnnotation" /> and also <xref
        linkend="chp.ValueTypes" />).</para>

        <para>The <classname>@EqualByContent</classname> annotation exists so
        that this semantic could, if required, by applied directly to an
        object without it necessarily also being annotated as a value.</para>

        <para>That said, this annotation is only really for completeness.
        Moreover, the semantic captured by this annotation is currently used
        by the framework (not in any object store nor viewer).</para>
      </sect1>

      <sect1>
        <title>@Executed</title>

        <para>The <classname>@Executed</classname> annotation is relevant only
        for client/server deployments (eg with the DnD viewer).</para>

        <para>In a client/server deployment, all methods for persistent
        objects are executed on the server-side and for transient objects are
        executed on the client-side.</para>

        <para>This annotation can be used to override that default.</para>

        <sect2>
          <title>Forcing a method to be executed on the client</title>

          <para>The <classname>@Executed(Where.LOCALLY)</classname> annotation
          marks an action method so that it executes on the client, rather
          than being forwarded to the server for execution. This is useful for
          methods that invoke a service that must be run client-side, for
          example spawning off a separate process (such as a web browser or
          Acrobat Reader).</para>
        </sect2>

        <sect2>
          <title>Forcing a method to be executed on the server</title>

          <para>The <classname>@Executed(Where.REMOTELY)</classname>
          annotation marks an action method so that it executes on the server,
          even though it would normally be executed on the client (as methods
          for transient objects are). This is useful for methods that although
          based on transient objects need access to persistent objects.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.ExplorationAnnotation">
        <title>@Exploration</title>

        <para>The <classname>@Exploration</classname> annotation marks an
        action method as available in exploration mode only, and therefore not
        intended for use in the production system. An exploration action may
        or may not also be a debug action (annotated with
        <classname>@Debug</classname>, see <xref
        linkend="sec.DebugAnnotation" />).</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeNewOrder() { ... }
    @Exploration
    public List&lt;Order&gt; listRecentOrders() { ... }
    ...
}</programlisting>

        <para>See also the <classname>@Prototype</classname> annotation, <xref
        linkend="sec.PrototypeAnnotation" /></para>
      </sect1>

      <sect1>
        <title>@Facets</title>

        <para>The <classname>@Facets</classname> annotation specifies
        <classname>FacetFactory</classname> implementations and so can be used
        to run install arbitrary <classname>Facet</classname>s for a type.
        Generally this is not needed, but can be useful for overriding a
        custom programming model where a <classname>FacetFactory</classname>
        is not typically included.</para>

        <para>See the core documentation for more on writing
        <classname>FacetFactory</classname>s.</para>
      </sect1>

      <sect1>
        <title>@FieldOrder</title>

        <note>
          <para>The recommended mechanism for specifying the order in which
          fields are listed to the user is <code>@MemberOrder</code> (see
          <xref linkend="sec.MemberOrderAnnotation" />)</para>
        </note>

        <para><code>@FieldOrder</code> provides a mechanism to specify the
        order in which fields appear in the user interface, in which the order
        is specified in one place in the class.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@FieldOrder("Name, Address, DateOfBirth, RecentOrders")
public class Customer {
    public Date getDateOfBirth() {...}
    public List&lt;Order&gt; getRecentOrders() {...}
    public String getAddress() {...}
    public String getName() {...}
    ...
}</programlisting>

        <para>The field names are not case sensitive.</para>

        <para>However, <code>@FieldOrder</code> is more 'brittle' to change:
        if you change the name of an existing property you will need to ensure
        that the corresponding name within the <code>@FieldOrder</code>
        annotation is also changed.</para>
      </sect1>

      <sect1 id="sec.HiddenAnnotation">
        <title>@Hidden</title>

        <para>The <literal moreinfo="none">@Hidden</literal> annotation
        indicates that the member (property, collection or action) to which it
        is applied should never be visible to the user. It can also be applied
        to service types (it has no effect if applied to entities or
        values).</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    @Hidden
    public int getInternalId() { ... }

    @Hidden
    public void updateStatus() { ... }
    ...
}</programlisting>

        <para>Or, applied to a service:</para>

        <programlisting format="linespecific">@Hidden
public class EmailService {
    public void sendEmail(...) { ... }
    ...
}</programlisting>

        <para>This annotation can also take a parameters indicating where and
        when it is to be hidden. For example:</para>

        <programlisting format="linespecific">public class Customer {
    @Hidden(when=When.ONCE_PERSISTED)
    public int getInternalId() { ... }
    ...
}</programlisting>

        <para>would show the <varname>Id</varname> until the object has been
        saved, and then would hide it. And:</para>

        <programlisting format="linespecific">public class Customer {
    @Hidden(where=Where.ALL_TABLES)
    public int getDateOfBirth() { ... }
    ...
}</programlisting>

        <para>would suppress the <varname>dateOfBirth</varname> property of a
        Customer from all tables.</para>

        <para>The acceptable values for the <varname>where</varname> parameter
        are:</para>

        <itemizedlist>
          <listitem>
            <para><code>Where.ANYWHERE</code></para>

            <para>The member should be hidden everywhere.</para>
          </listitem>

          <listitem>
            <para><code>Where.OBJECT_FORMS</code></para>

            <para>The member should be hidden when displayed within an object
            form. For most viewers, this applies to property and collection
            members, not actions.</para>
          </listitem>

          <listitem>
            <para><code>Where.PARENTED_TABLES</code></para>

            <para>The member should be hidden when displayed as a column of a
            table within a parent object's collection. For most (all?)
            viewers, this will have meaning only if applied to a property
            member.</para>
          </listitem>

          <listitem>
            <para><code>Where.STANDALONE_TABLES</code></para>

            <para>The member should be hidden when displayed as a column of a
            table showing a standalone list of objects, for example as
            returned by a repository query. For most (all?) viewers, this will
            have meaning only if applied to a property member.</para>
          </listitem>

          <listitem>
            <para><code>Where.ALL_TABLES</code></para>

            <para>The member should be /hidden when displayed as a column of a
            table, either an object's * collection or a standalone list. This
            combines <classname>PARENTED_TABLES</classname> and
            <classname>STANDALONE_TABLES</classname>.</para>
          </listitem>

          <listitem>
            <para><code>Where.NOWHERE</code></para>

            <para>Acts as an override if a member would normally be hidden as
            a result of some other convention. For example, if a property is
            annotated with <classname>@Title</classname> (see <xref
            linkend="sec.TitleAnnotation" />), then normally this should be
            hidden from all tables. Additionally annotating with
            <code>@Hidden(where=Where.NOWHERE)</code> overrides this.</para>
          </listitem>
        </itemizedlist>

        <para>The acceptable values for the <varname>when</varname> parameter
        are:</para>

        <itemizedlist>
          <listitem>
            <para><code>When.ALWAYS</code></para>

            <para>The member should be hidden at all times.</para>
          </listitem>

          <listitem>
            <para><code>When.NEVER</code></para>

            <para>The member should never be hidden (unless disabled through
            some other mechanism, for example an imperative
            <methodname>disableXxx()</methodname> supporting method)..</para>
          </listitem>

          <listitem>
            <para><code>When.ONCE_PERSISTED</code></para>

            <para>The member should be visible for transient objects, but
            hidden for persisted objects.</para>
          </listitem>

          <listitem>
            <para><code>When.UNTIL_PERSISTED</code></para>

            <para>The member should be hidden for transient objects, but
            visible for persisted objects.</para>
          </listitem>
        </itemizedlist>

        <para>By default the annotated property or action is always hidden (ie
        defaults to <classname>Where.ANYWHERE</classname>,
        <classname>When.ALWAYS</classname>).</para>
      </sect1>

      <sect1>
        <title>@Idempotent (deprecated)</title>

        <para>Equivalent to using <code>@ActionSemantics(Of.IDEMPOTENT)</code>
        on an action.</para>
      </sect1>

      <sect1>
        <title>@Ignore (deprecated)</title>

        <para>Equivalent to using <code>@Programmatic</code>. The
        <classname>@Programmatic</classname> annotation was introduced because
        <classname>@Ignore</classname> can easily clash with
        <classname>@org.junit.Ignore</classname>.</para>
      </sect1>

      <sect1>
        <title>@Immutable</title>

        <para>The <literal moreinfo="none">@Immutable</literal> annotation may
        be applied to a class, and indicates to the framework that the state
        of such objects may not be changed. The viewers will prevent any
        change through the user interface, and moreover the object stores will
        reject any changes to the objects that might have occurred
        programmatically.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@Immutable
public class Country {
    ...
}</programlisting>

        <para>This annotation can also take a single parameter indicating when
        it is to become immutable. For example:</para>

        <programlisting format="linespecific">@Immutable(When.ONCE_PERSISTED)
public class Email {
    ...
}</programlisting>

        <para>This would allow the user to create an email object and set it
        up, and then prevent any changes once it has been saved.</para>

        <para>The acceptable values for the parameter are:</para>

        <itemizedlist>
          <listitem>
            <para><code>When.ALWAYS</code></para>
          </listitem>

          <listitem>
            <para><code>When.NEVER</code></para>
          </listitem>

          <listitem>
            <para><code>When.ONCE_PERSISTED</code></para>
          </listitem>

          <listitem>
            <para><code>When.UNTIL_PERSISTED</code></para>
          </listitem>
        </itemizedlist>

        <para>By default the annotated property or action is always immutable
        (ie defaults to <classname>When.ALWAYS</classname>).</para>
      </sect1>

      <sect1 id="sec.MaskAnnotation">
        <title>@Mask</title>

        <para>The <literal moreinfo="none">@Mask</literal> annotation may be
        applied to any property, or to any parameter within an action method,
        that allows the user to type in text as input. It can also annotate a
        string-based value type, and thereby apply to all properties or
        parameters of that type.</para>

        <para>The mask serves to validate, and potentially to normalise, the
        format of the input. The characters that can be used are based on
        Swing's <classname>javax.swing.text.MaskFormatter</classname>, and
        also Java's <classname>java.util.SimpleDateFormat</classname>.</para>

        <para>For example, on a property:</para>

        <programlisting format="linespecific">public class Email {
    @Mask("(NNN)NNN-NNNN")
    public String getTelephoneNumber() {...}
    public void setTelephoneNumber(String telNo) {...}
    ...
}</programlisting>

        <para>Or, on an action parameter:</para>

        <programlisting format="linespecific">public void ContactRepository {
    public void newContact(
            @Named("Contact Name") String contactName
           ,@Mask("(NNN)NNN-NNNN") 
            @Named("Telephone Number") String telNo) { 
        ...
    }
    ... 
}</programlisting>

        <para>Or, on a value type:</para>

        <programlisting format="linespecific">@Value(...)
@MaxLength(30)
public class CustomerFirstName {
    ...
}</programlisting>

        <para>See also <classname>@RegEx</classname> annotation, <xref
        linkend="sec.RegExAnnotation" />.</para>
      </sect1>

      <sect1 id="sec.MaxLengthAnnotation">
        <title>@MaxLength</title>

        <para>The <literal moreinfo="none">@MaxLength</literal> annotation
        indicates the maximum number of characters that the user may enter
        into a <literal moreinfo="none">String</literal> property, or a
        <literal moreinfo="none">String</literal> parameter in an action, or
        for a string-based value type. It is ignored if applied to any other
        type.</para>

        <para>For example, on a property:</para>

        <programlisting format="linespecific">public class Customer {
    @MaxLength(30)
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
    ...
}</programlisting>

        <para>Or, on an action parameter:</para>

        <programlisting format="linespecific">public class CustomerRepository {
    public Customer newCustomer(
        @MaxLength(30)
        @Named("First Name") String firstName
       ,@MaxLength(30)
        @Named("Last Name") String lastName) {
    ...
}</programlisting>

        <para>Or, for a value type:</para>

        <programlisting format="linespecific">@Value(...)
@MaxLength(30)
public class CustomerFirstName {
    ...
}</programlisting>

        <para>If the model is being persisted to a relational database then
        <literal moreinfo="none">@MaxLength</literal> should be specified for
        all <literal moreinfo="none">String</literal> properties and action
        parameters.</para>
      </sect1>

      <sect1 id="sec.MemberGroupsAnnotation">
        <title>@MemberGroups</title>

        <para><code>@MemberGroups</code> is designed to work in conjunction
        with <classname>@MemberOrder</classname> (see <xref
        linkend="sec.MemberOrderAnnotation" />), and specifies the order in
        which groups of members should be rendered.</para>

        <para>For example:</para>

        <programlisting>@MemberGroups({"General", "Dates", "Other"})
public Class Customer {
    @MemberOrder(name="General", sequence="1.1")
    public String getFirstName() {...}
    public void setFirstName(value as String) {...}

    @MemberOrder(name="General", sequence="1.2")
    public String getLastName() {...}
    public void setLastName(value as String) {...}

    @MemberOrder(name="Other", sequence="1")
    public String getAddress() {...}
    public void setAddress(value as String) {...}

    @MemberOrder(name="Dates", sequence="1")
    public Date getDateOfBirth() {...}
    public void setDateOfBirth(value as Date) {...}
    ...
}   </programlisting>

        <para>If the <classname>@MemberOrder</classname>'s name is not
        specified, then its group is assumed to be
        "<literal>General</literal>".</para>
      </sect1>

      <sect1 id="sec.MemberOrderAnnotation">
        <title>@MemberOrder</title>

        <para><code>@MemberOrder</code> is the recommended mechanism for
        specifying the order in which fields and/or actions are presented to
        the user. (<code>@ActionOrder</code> and <code>@FieldOrder</code>
        provide alternative, deprecated mechanisms).</para>

        <para><code>@MemberOrder</code> is specified at the individual member
        level, relative to other members, as a string. The simplest convention
        is to use numbers - 1, 2, 3 - though it is a better idea to leave gaps
        in the numbers - 10, 20, 30 perhaps - such that a new member may be
        added without having to edit existing numbers. A useful alternative is
        to adopt the 'dewey-decimal' notation - 1, 1.1, 1.2, 2, 3, 5.1.1,
        5.2.2, 5.2, 5.3 - which allows for an indefinite amount of future
        insertion, and allows subclasses to insert their class members as
        required.</para>

        <para>For example:</para>

        <programlisting>public Class Customer {
    @MemberOrder(sequence="2.1")
    public String getAddress() {...}
    public void setAddress(value as String) {...}

    @MemberOrder(sequence="1.1")
    public String getFirstName() {...}
    public void setFirstName(value as String) {...}

    @MemberOrder(sequence="1.2")
    public String getLastName() {...}
    public void setLastName(value as String) {...}

    @MemberOrder(sequence="3")
    public Date getDateOfBirth() {...}
    public void setDateOfBirth(value as Date) {...}
    ...
}   </programlisting>

        <para>If a member does not have a specified order then it will be
        placed after those that are specified. Two members may have the same
        sequence specifier, but in such a case the relative ordering of those
        members will be indeterminate.</para>

        <note>
          <para>Certain styles of user interface may lay out an object's
          properties and its collections separately, in which case the
          relative member order of properties and collections will be
          evaluated separately. In general, though, consider the layout of all
          properties and collections together, and of all actions
          together.</para>
        </note>

        <para>As a refinement to this, some viewers support the notion of
        grouping members together. In this case the <varname>name</varname>
        attribute can be specified.</para>

        <para>For example, the following can be used to group
        properties:</para>

        <programlisting>public Class Customer {
    @MemberOrder(name="General", sequence="1.1")
    public String getFirstName() {...}
    public void setFirstName(value as String) {...}

    @MemberOrder(name="General", sequence="1.2")
    public String getLastName() {...}
    public void setLastName(value as String) {...}

    @MemberOrder(name="Other", sequence="1")
    public String getAddress() {...}
    public void setAddress(value as String) {...}

    @MemberOrder(name="Dates", sequence="1")
    public Date getDateOfBirth() {...}
    public void setDateOfBirth(value as Date) {...}
    ...
}   </programlisting>

        <para>In this case the <varname>sequence</varname> is ordered with
        respect to the <varname>name</varname>. If using group names in this
        way, typically the MemberGroups annotation (see <xref
        linkend="sec.MemberGroupsAnnotation" />) should also be specified,
        allowing the order of the groups themselves to be sorted.</para>

        <para>Grouping can also be performed on actions. Some viewers (for
        example the Wicket viewer) support the idea that the group name can be
        the name of a collection. In this case, the action is rendered "near
        to" the collection (for example, to support add or remove of
        elements).</para>

        <para>For example:</para>

        <programlisting>public Class Customer {

    public List&lt;CommunicationChannel&gt; getCommunicationChannels() { ... }

    ...
    @MemberOrder(name="communicationChannels", sequence="1.1")
    public void addCommunicationChannel(...) { ... }

    @MemberOrder(name="communicationChannels", sequence="1.2")
    public void removeCommunicationChannel(...) { ... }

    ...
}   </programlisting>
      </sect1>

      <sect1>
        <title>@MultiLine</title>

        <para>The <literal moreinfo="none">@MultiLine</literal> annotation
        provides information about the carriage returns in a <literal
        moreinfo="none">String</literal> property or action parameter, or for
        a string-based value type. It also implies a hint to the viewer that
        the widget to be used should be over multiple lines (eg a text area
        rather than a text field), with appropriate wrapping and/or
        scrollbars.</para>

        <para>More formally, the annotation indicates that:</para>

        <itemizedlist>
          <listitem>
            <para>the <code>String</code> property or parameter may contain
            carriage returns, and</para>
          </listitem>

          <listitem>
            <para>(optionally) the typical number of such carriage returns
            (meaning the number of rows in the text area), and</para>
          </listitem>

          <listitem>
            <para>(optionally) that the text should be wrapped (the default is
            that text is not wrapped).</para>
          </listitem>
        </itemizedlist>

        <warning>
          <para>Currently the <literal
          moreinfo="none">preventWrapping</literal> functionality is not fully
          implemented.</para>
        </warning>

        <para>The syntax is:</para>

        <para><literal
        moreinfo="none">@MultiLine([numberOfLines=&lt;typicalNumberOfCRs&gt;]
        [,preventWrapping=&lt;false|true&gt;])</literal></para>

        <para>For example:</para>

        <programlisting format="linespecific">public class BugReport {
    @MultiLine(numberOfLines=10)
    public String getStepsToReproduce() { ... }
    public void setStepsToReproduce(String stepsToReproduce) { ... }
    ...
}</programlisting>

        <para>Here the <literal moreinfo="none">stepsToReproduce</literal> may
        be displayed in a text area of 10 rows, with no wrapping. A horizontal
        scrollbar may appear if the number of characters on any given row
        exceeds the width.</para>

        <para>Another example:</para>

        <programlisting format="linespecific">public class Email {
    @MultiLine(numberOfLines=20, preventWrapping=false)
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

        <para>Here the body should be displayed in a text area of 20 rows,
        with wrapping.</para>

        <para>If the annotation is combined with the <literal
        moreinfo="none">@TypicalLength</literal>, then the expected width of
        the text area in the user interface will be determined by the value of
        the typical length divided by the number of specified lines. For
        example:</para>

        <programlisting format="linespecific">public class Email {
    @MultiLine(numberOfLines=20, preventWrapping=false)
    @TypicalLength(800)
    public String getBody() { ... }
    public void setBody(String body) { ... }
    ...
}</programlisting>

        <para>Here the body will (likely be) displayed in a text area of 20
        rows, with 40 columns.</para>
      </sect1>

      <sect1>
        <title>@MustSatisfy</title>

        <para>The <literal moreinfo="none">@MustSatisfy</literal> annotation
        allows validation to be applied to properties and parameters using an
        (implementation of a)
        <classname>org.apache.isis.applib.spec.Specification</classname>
        object.</para>

        <para>For example, on a property:</para>

        <programlisting format="linespecific">public class Customer {
    @MustSatisfy(StartWithCapitalLetterSpecification.class)
    public String getFirstName() { ... }
    ...
}</programlisting>

        <para>Or, on an action parameter:</para>

        <programlisting format="linespecific">public class CustomerRepository {
    public Customer newCustomer(
            @MustSatisfy(StartWithCapitalLetterSpecification.class)
            @Named("First Name") firstName
           ,@MustSatisfy(StartWithCapitalLetterSpecification.class)
            @Named("Last Name") lastName) {
        ...
    }
    ...
}</programlisting>

        <para>The <classname>Specification</classname> is consulted during
        validation, being passed the proposed value.</para>

        <para>An alternative to using <classname>@MustSatisfy</classname> is
        to define a custom value type, see <xref
        linkend="chp.ValueTypes" />.</para>
      </sect1>

      <sect1 id="sec.NamedAnnotation">
        <title>@Named</title>

        <para>The <literal moreinfo="none">@Named</literal> annotation is used
        when you want to specify the way something is named on the user
        interface i.e. when you do not want to use the name generated
        automatically by the system. It can be applied to objects, members
        (properties, collections, and actions) and to parameters within an
        action method.</para>

        <para><warning>
            <para>Generally speaking it is better to rename the property,
            collection or action. The only common case where
            <literal>@Named</literal> is common is to rename parameters for
            built-in value types. Even here though a custom value type can be
            defined using <classname>@Value</classname> so that the value type
            is used as the parameter name. <classname>@Named</classname> may
            also be used if the name needs punctuation or other symbols in the
            name presented to the user.</para>
          </warning></para>

        <sect2>
          <title>Specifying the name of an object</title>

          <para>By default the name of an object is derived, reflectively from
          the class name. To specify a different name for an object, use the
          <literal moreinfo="none">@Named</literal> annotation in front of the
          class declaration.</para>

          <para>For example:</para>

          <programlisting format="linespecific">@Named("Customer")
public class CustomerImpl implements Customer{
   ...
}</programlisting>

          <para>See also the <literal moreinfo="none">@Plural</literal>
          annotation, <xref linkend="sec.PluralAnnotation" />.</para>
        </sect2>

        <sect2>
          <title>Specifying the name of a class member</title>

          <para>By default, the name of a class member (a property, collection
          or action) presented to the user is derived, reflectively, from the
          name of the member defined in the program code. To specify a
          different name use the <literal moreinfo="none">@Named
          </literal>annotation immediately before the member
          declaration.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    <emphasis role="strong">@Named("Given Name")</emphasis>
    public String getFirstName() { ... }

    <emphasis role="strong">@Named("Family Name")</emphasis>
    public String getSurname() { ... }

    public CreditRating getCreditRating() { ... }
}</programlisting>

          <para>Note that the framework provides a separate and more powerful
          mechanism for internationalisation.</para>
        </sect2>

        <sect2>
          <title>Specifying the name for an action parameter</title>

          <para>The most common usage of <literal
          moreinfo="none">@Named</literal> is be to specify names for the
          parameters of an action. This is because the parameter name declared
          in the code for the action method cannot be picked up reflectively
          (by default, the user interface will use the type of the parameter
          as the name; for a String or a Boolean, this is almost certainly not
          what is required).</para>

          <para>To specify the name of a parameter, the <literal
          moreinfo="none">@Named</literal> annotation is applied 'in-line'
          (i.e. preceding the individual parameter declaration.</para>

          <para>For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
            Product product
           ,@Named("Quantity")
            int quantity) {
        Order order = newTransientInstance(Order.class);
        order.modifyCustomer(this);
        order.modifyProduct(product);
        order.setQuantity(quantity);        
        return order;
    }
    ...
}</programlisting>

          <para>An alternative is to use a value type, as described in <xref
          linkend="chp.ValueTypes" />.</para>
        </sect2>
      </sect1>

      <sect1 id="sec.NotContributedAnnotation">
        <title>@NotContributed</title>

        <para>The <classname>@NotContributed</classname> annotation applies
        only to action methods, and specifically to the actions of services.
        If present, it indicates that the action should not be contributed to
        any of its domain object arguments.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class OrderServices {
    @NotContributed
    public void cancel(Order order);
    ...
}</programlisting>

        <para>If the action should neither be contributed nor appear in the
        service's service menu (see <xref
        linkend="sec.NotInServiceMenuAnnotation" />), then you could instead
        simply mark it as <classname>@Hidden</classname> (see <xref
        linkend="sec.HiddenAnnotation" />).</para>
      </sect1>

      <sect1 id="sec.NotInServiceMenuAnnotation">
        <title>@NotInServiceMenu</title>

        <para>The <classname>@NotInServiceMenu</classname> annotation applies
        only to action methods, and specifically to the actions of services.
        If present, it indicates that the action should not appear in the
        service menu for the service. It may, however, still be contributed to
        any of its domain object arguments.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class OrderServices {
    @NotInServiceMenu
    public void cancel(Order order);
    ...
}</programlisting>

        <para>If the action should neither be contributed (see <xref
        linkend="sec.NotContributedAnnotation" />) nor appear in the service's
        service menu, then you could instead simply mark it as
        <classname>@Hidden</classname> (see <xref
        linkend="sec.HiddenAnnotation" />).</para>
      </sect1>

      <sect1 id="not-persistable">
        <title>@NotPersistable</title>

        <para>The <classname>@NotPersistable</classname> annotation indicates
        that transient instances of this class may be created but may not be
        persisted. The framework will not provide the user with an option to
        'save' the object, and attempting to persist such an object
        programmatically would be an error.</para>

        <para>For example:</para>

        <programlisting format="linespecific"><classname>@NotPersistable</classname>
public class InputForm {
    // members and actions here
}</programlisting>

        <para>This annotation can also take a single parameter indicating
        whether it is only the user that cannot persist the object, for
        example the following code would prevent the user from saving the
        object (via the viewer) but still allow the program to persist the
        object.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@NotPersistable(By.USER)
public class InputForm {
    ...
}</programlisting>

        <para>The acceptable values for the parameter are:</para>

        <itemizedlist>
          <listitem>
            <para><code>By.USER</code></para>
          </listitem>

          <listitem>
            <para><code>By.USER_OR_PROGRAM</code></para>
          </listitem>
        </itemizedlist>

        <para>By default the annotated object is effectively transient (ie
        default to
        <classname>By</classname>.<varname>USER_OR_PROGRAM</varname>).</para>
      </sect1>

      <sect1>
        <title>@NotPersisted</title>

        <para>The <classname>@NotPersisted</classname> annotation indicates
        that the property is not to be persisted.</para>

        <note>
          <para>In many cases the same thing can be achieved simply by
          providing the property with a 'getter' but no 'setter'.</para>
        </note>

        <para>For example:</para>

        <programlisting format="linespecific">public class Order {

    @NotPersisted
    public Order getPreviousOrder() {...}
    public void setPreviousOrder(Order previousOrder) {...}

    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@ObjectType</title>

        <para>The <classname>@ObjectType</classname> annotation is used to
        provide a unique abbreviation for the object's class name. This is
        used internally to generate a string representation of an objects
        identity (the Oid).</para>

        <para>For example:</para>

        <programlisting format="linespecific">@ObjectType("ORD")
public class Order {

    ...
}</programlisting>

        <para>If no <code>@ObjectType</code> annotation is present, then the
        framework uses the fully-qualified class name.</para>

        <para>If an <code>@ObjectType</code> is not unique, then the framework
        will fail to boot.</para>
      </sect1>

      <sect1>
        <title>@Optional</title>

        <para>By default, the system assumes that all properties of an object
        are required, and therefore will not let the user save a new object
        unless a value has been specified for each property. Similarly, by
        default, the system assumes that all parameters in an action are
        required and will not let the user execute that action unless values
        have been specified for each parameter.</para>

        <para>To indicate that either a property, or an action parameter, is
        optional, use the <literal moreinfo="none">@Optional</literal>
        annotation.</para>

        <note>
          <para>The <literal moreinfo="none">@Optional</literal>annotation has
          no meaning for a primitive property (or parameter) such as <literal
          moreinfo="none">int</literal> - because primitives will always
          return a default value (e.g. zero). If optionality is required, then
          use the corresponding wrapper class (e.g. java.lang.Integer).</para>
        </note>

        <sect2>
          <title>Making a property optional</title>

          <para>Annotate the getter to indicate that a property is
          <classname>@Optional</classname>. For example:</para>

          <programlisting format="linespecific">public class Order {
    public Product getProduct() { ... }
    
    public java.util.Date getShipDate() { ... }
    public void setShipDate(Date java.util.shipDate) { ... }

    @Optional
    public String getComments() { ... }
    public void setComments(String comments) { ... }
}</programlisting>

          <para>Here the <literal moreinfo="none">product</literal> and
          <literal moreinfo="none">shipDate</literal> properties are both
          required, but the <literal moreinfo="none">comments</literal>
          property is optional.</para>
        </sect2>

        <sect2>
          <title>Making an action parameter optional</title>

          <para>To indicate that an action may be invoked without having to
          specify a value for a particular parameter, annotate with
          <literal>@Optional</literal>. For example:</para>

          <programlisting format="linespecific">public class Customer {
    public Order placeOrder(
            Product product
           ,@Named("Quantity") int quantity
           ,@Optional @Named("Special Instructions") String instr) {
        ...
    }
    ...
}</programlisting>
        </sect2>
      </sect1>

      <sect1>
        <title>@Paged</title>

        <para>This annotation is used to indicate that parented and/or
        standalone collections should be paginated.</para>

        <para>When annotated on a collection, <classname>@Paged</classname>
        indicates the page size of a parented collection. When annotated on a
        type, <classname>@Paged</classname> indicates the page size of a
        standalone collection.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@Paged(30)
public class Order {

    @Paged(15)
    public List&lt;LineItem&gt; getDetails() {...}
}</programlisting>

        <para>This indicates a page size of 15 for parented collections, and a
        page size of 30 for standalone collections.</para>

        <para>When omitting a parameter value or omitting the annotation
        completely, the configured defaults in
        <filename>isis.properties</filename> wil be used.</para>

        <para>For example:</para>

        <para><programlisting>isis.viewers.paged.standalone=20
isis.viewers.paged.parented=5</programlisting></para>

        <para>This indicates a page size of 5 for parented collections and a
        page size of 20 for standalone collections.</para>
      </sect1>

      <sect1>
        <title>@Parseable</title>

        <para>Parseability means being able to parse a string representation
        into an object by way of the
        <classname>org.apache.isis.applib.adapters.Parser</classname>
        interface. Generally this only applies to value types, where the
        <classname>@Value</classname> annotation (see <xref
        linkend="sec.ValueAnnotation" />) implies encodability through the
        <classname>ValueSemanticsProvider</classname> interface (see <xref
        linkend="chp.ValueTypes" />).</para>

        <para>For these reasons the <classname>@Parser</classname> annotation
        is generally never applied directly, but can be thought of as a
        placeholder for future enhancements whereby non-value types might also
        have be able to be parsed. For example, a
        <classname>Customer</classname> could in theory be parsed from a
        string representing that <classname>Customer</classname>'s title
        (perhaps in conjunction with some other annotation to determine the
        repository by which to perform the lookup).</para>
      </sect1>

      <sect1 id="sec.PluralAnnotation">
        <title>@Plural</title>

        <para>When the framework displays a collection of several objects it
        may use the plural form of the object type in the title. By default
        the plural name will be created by adding an 's' to the end of the
        singular name (whether that is the class name or another name
        specified using <literal moreinfo="none">@Named</literal>). Where the
        single name ends in 'y' then the default plural name will end in 'ies'
        - for example a collection of <literal
        moreinfo="none">Country</literal> objects will be titled 'Countries'.
        Where these conventions do not work, the programmer may specify the
        plural form of the name using <classname>@Plural</classname>. For
        example:</para>

        <programlisting format="linespecific"><emphasis role="strong">@Plural("Children")</emphasis>
public class Child {
    // members and actions here
}</programlisting>
      </sect1>

      <sect1>
        <title>@PublishedAction</title>

        <para>See <ulink
        url="http://isis.apache.org/core/publishing-service.html">Isis
        website</ulink>.</para>
      </sect1>

      <sect1>
        <title>@PublishedObject</title>

        <para>See <ulink
        url="http://isis.apache.org/core/publishing-service.html">Isis
        website</ulink>.</para>
      </sect1>

      <sect1>
        <title>@Programmatic</title>

        <para>The <classname>@Programmatic</classname> annotation can be used
        to cause Apache Isis to complete ignore a class member. This means it
        won't appear in any viewer, its value will not be persisted, and it
        won't appear in any XML snapshots (see <xref
        linkend="chp.XmlSnapshots" />).</para>

        <para>A common use-case is to ignore implementation-level artifacts.
        For example:</para>

        <programlisting format="linespecific">public class Customer implements Comparable&lt;Customer&gt; {
    ...
    @Programmatic
    public int compareTo(Customer c) { 
        return getSalary() - c.getSalary();
    }
    ...
}</programlisting>

        <para>Note that <methodname>@Programmatic</methodname> does not simply
        imply <methodname>@Hidden</methodname> and
        <methodname>@NotPersisted</methodname>; it actually means that the
        class member will not be part of the Isis metamodel.</para>
      </sect1>

      <sect1 id="sec.PrototypeAnnotation">
        <title>@Prototype</title>

        <para>The <classname>@Prototype</classname> annotation marks an action
        method as available in prototype mode only, and therefore not intended
        for use in the production system. A prototype action may or may not
        also be a debug action (annotated with <classname>@Debug</classname>,
        see <xref linkend="sec.DebugAnnotation" />).</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Customer {
    public Order placeNewOrder() { ... }
    @Prototype
    public List&lt;Order&gt; listRecentOrders() { ... }
    ...
}</programlisting>

        <para>See also the <classname>@Exploration</classname> annotation,
        <xref linkend="sec.ExplorationAnnotation" /></para>
      </sect1>

      <sect1>
        <title>@QueryOnly (deprecated)</title>

        <para>Equivalent to using <code>@ActionSemantics(Of.SAFE)</code> on an
        action.</para>
      </sect1>

      <sect1 id="sec.RegExAnnotation">
        <title>@RegEx</title>

        <para>The <literal moreinfo="none">@RegEx</literal> annotation may be
        applied to any string property, or to any parameter within an action
        method. It can also be applied to any string-based value type. It
        serves both to validate and potentially to normalise the format of the
        input. <literal moreinfo="none">@Regex</literal> is therefore similar
        in use to <literal moreinfo="none">@Mask</literal> (see <xref
        linkend="sec.MaskAnnotation" />) but provides more flexibility.</para>

        <para>The syntax is:</para>

        <para><literal moreinfo="none">@RegEx(validation = "regEx string",
        format = "regEx string", caseSensitive =
        &lt;true|false&gt;)</literal></para>

        <para>Only the first parameter is required; the format defaults to "no
        formatting", and caseSensitive defaults to false.</para>

        <para>For example, on a property:</para>

        <programlisting format="linespecific">public class Customer {
    @RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")
    public String getEmail() {}
    ...
}</programlisting>

        <para>Or, on a parameter:</para>

        <programlisting format="linespecific">public class Customer {
    public void updateEmail(
            @RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")
            @Named("Email") String email) {
        ...
    }
    ...
)</programlisting>

        <para>Or, on a value type:</para>

        <programlisting format="linespecific">@Value(...)
@RegEx(validation = "(\\w+\\.)*\\w+@(\\w+\\.)+[A-Za-z]+")
public class EmailAddress {
   ...
y}</programlisting>
      </sect1>

      <sect1>
        <title>@Render</title>

        <para>The <classname>@Render</classname> annotation is a hint for
        properties and collections to indicate that a value property should be
        rendered lazily (rather than eagerly, as usual), or that a reference
        property or collection should be rendered eagerly (rather than lazily,
        as usual).</para>

        <para>Viewers can use this to present the property/collection in an
        appropriate manner:</para>

        <itemizedlist>
          <listitem>
            <para>an <classname>Order</classname>'s
            <methodname>lineItems</methodname> collection might initially be
            rendered expanded form so that the user could see a list of line
            items immediately when the order is rendered. This is the most
            common use case.</para>
          </listitem>

          <listitem>
            <para>a (reference) property of type
            <classname>Address</classname> might show the details of the
            referenced <classname>Address</classname> in a box</para>
          </listitem>
        </itemizedlist>

        <para>At the same time, an object store might use this to defer lazy
        loading of values that represent blobs or clobs.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public class Order {
    @Render(Type.EAGERLY)
    public List&lt;LineItem&gt; getDetails() { ... }

    ...
}</programlisting>

        <para>For properties and collections there is some similarity between
        this concept and that of eager-loading as supported by some object
        stores. Indeed, some object stores may choose use their own specific
        annotations (eg a JDO default fetch group) in order to infer this
        semantic.</para>
      </sect1>

      <sect1>
        <title>@Resolve (deprecated)</title>

        <para>The <code>@Resolve</code> annotation is deprecated, and has been
        replaced by the <code>@Render</code> annotation (with exact same
        semantics).</para>
      </sect1>

      <sect1 id="sec.TitleAnnotation">
        <title>@Title</title>

        <para>The <literal moreinfo="none">@Title</literal> annotation is used
        to indicate which property or properties make up the object title. If
        more than one property is used, the order can be specified (using the
        same Dewey-decimal notation as used by
        <classname>@MemberOrder</classname>) and the string to use between the
        components can also be specified.</para>

        <para>For example:</para>

        <programlisting format="linespecific">public void Customer {
    @Title(sequence="1.0")
    public String lastName() { ... }
    ...
    @Title(sequence="1.5", prepend=", ")
    public String firstName() { ... }
    ...
    @Title(sequence="1.7", append=".")
    public String midInitial() { ... }
    ...
}</programlisting>

        <para>could be used to create names of the style "Bloggs, Joe
        K."</para>

        <para>It is also possible to annotate reference properties; in this
        case the title will return the title of the referenced object (rather
        than, say, its string representation).</para>

        <para>An additional convention for <classname>@Title</classname>
        properties is that they are hidden in tables (in other words, it
        implies <code>@Hidden(where=Where.ALL_TABLES)</code>. For viewers that
        support this annotation (for example, the Wicket viewer), this
        convention excludes any properties whose value is already present in
        the title column. This convention can be overridden using
        <code>@Hidden(where=Where.NOWHERE)</code>.</para>
      </sect1>

      <sect1>
        <title>@TypeOf</title>

        <para>The <literal moreinfo="none">@TypeOf</literal> annotation is
        used to specify the type of elements in a collection, when for
        whatever reason it is not possible to use generics.</para>

        <note>
          <para>Given that Apache Isis only supports Java 1.6 and later, it's
          not that obvious what such a reason might be...</para>
        </note>

        <para>For example:</para>

        <programlisting format="linespecific">public void AccountService {
    @TypeOf(Customer.class)
    public List errantAccounts() {
        return CustomerDatabase.allNewCustomers();
    }
    ...
}</programlisting>
      </sect1>

      <sect1>
        <title>@TypicalLength</title>

        <para>The <literal moreinfo="none">@TypicalLength</literal> annotation
        indicates the typical length of a <literal
        moreinfo="none">String</literal> property or <literal
        moreinfo="none">String</literal> parameter in an action. It can also
        be specified for string-based value types.</para>

        <para>The information is generally used by the viewing mechanism to
        determine the space that should be given to that property or parameter
        in the appropriate view. If the typical length is the same as the
        <literal moreinfo="none">@MaxLength</literal> (see <xref
        linkend="sec.MaxLengthAnnotation" />) then there is no need to specify
        <literal moreinfo="none">@TypicalLength</literal> as well. If the
        value specified is zero or negative then it will be ignored.</para>

        <para>For example, for a property:</para>

        <programlisting format="linespecific">public class Customer {
    @MaxLength(30)
    @TypicalLength(20)
    public String getFirstName() { ... }
    public void setFirstName(String firstName) { ... }
}</programlisting>

        <para>Or, for a parameter:</para>

        <programlisting format="linespecific">public class CustomerRepository {
    public Customer newCustomer(
            @TypicalLength(20)
            @Named("First Name") String firstName
           ,@TypicalLength(20)
            @Named("Last Name") String lastName) {
        ...
    }
    ...
}</programlisting>

        <para>Or, for value type:</para>

        <programlisting format="linespecific">@Value(...)
@TypicalLength(20)
public class FirstName {
    ...
}</programlisting>
      </sect1>

      <sect1 id="sec.ValueAnnotation">
        <title>@Value</title>

        <para>The <literal moreinfo="none">@Value</literal> annotation
        indicates that a class should be treated as a value type rather than
        as a reference (or entity) type. It does this providing an
        implementation of a
        <classname>org.apache.isis.applib.adapters.ValueSemanticsProvider</classname>.</para>

        <para>For example:</para>

        <programlisting format="linespecific">@Value(semanticsProviderClass=ComplexNumberValueSemanticsProvider.class)
public class ComplexNumber {
    ...
}</programlisting>

        <para>The <classname>ValueSemanticsProvider</classname> allows the
        framework to interact with the value, parsing strings and displaying
        as text, and encoding/decoding (for serialization). For more
        information, see <xref linkend="chp.ValueTypes" />.</para>
      </sect1>

      <sect1>
        <title>@ViewModel</title>

        <para>The <classname>@ViewModel</classname> annotation allows the
        developer to declare that a domain object is intended to be used as a
        view model. As such, any changes to its structure are guaranteed to be
        backwardly compatible.</para>

        <para>The annotation was originally introduced to support a
        requirement of the RestfulObjects viewer which directly expose the
        domain objects as RESTful representations</para>

        <para>For example, a domain object that represents a summary of a
        <classname>Customer</classname> and their most recent
        <classname>Order</classname>s might be annotated as:</para>

        <programlisting format="linespecific">@NotPersistable
@ViewModel
public class CustomerAndOrdersViewModel {
   ...
}</programlisting>
      </sect1>
    </appendix>

    <appendix id="apx.DomainObjectContainer">
      <title><classname>DomainObjectContainer</classname> interface</title>

      <abstract>
        <para>Provides a single point of contact from domain objects into the
        <emphasis>Apache Isis</emphasis> framework.</para>
      </abstract>

      <para>The <classname>DomainObjectContainer</classname> interface
      provides a single point of contact from domain objects into the
      <emphasis>Isis</emphasis> framework. It can also be used as a
      lightweight general purpose repository during prototyping.</para>

      <table>
        <title>DomainObjectContainer methods (1 of 2)</title>

        <tgroup cols="3">
          <colspec align="center" colwidth="70" />

          <colspec align="left" colwidth="180" />

          <colspec align="left" />

          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Method</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry morerows="2">Object creation</entry>

              <entry><methodname>newTransientInstance(Class&lt;T&gt;)</methodname></entry>

              <entry>Creates new non-persisted object</entry>
            </row>

            <row>
              <entry><methodname>newPersistentInstance(Class&lt;T&gt;)</methodname></entry>

              <entry>Creates new object, will be persisted at end of
              action</entry>
            </row>

            <row>
              <entry><methodname>newInstance(Class&lt;T&gt;,
              Object)</methodname></entry>

              <entry>Creates object in state persistence state as that
              provided</entry>
            </row>

            <row>
              <entry morerows="1">Validation</entry>

              <entry><methodname>isValid(Object)</methodname></entry>

              <entry>whether object is valid</entry>
            </row>

            <row>
              <entry><methodname>validate(Object)</methodname></entry>

              <entry>reason why object is invalid (if any)</entry>
            </row>

            <row>
              <entry morerows="6">Generic Repository</entry>

              <entry><methodname>allInstances(Class&lt;T&gt;)</methodname></entry>

              <entry>All persisted instances of specified type</entry>
            </row>

            <row>
              <entry><methodname>allMatches(Class&lt;T&gt;,
              Filter&lt;T&gt;)</methodname></entry>

              <entry>All persistenced instances of specified type matching
              filter</entry>
            </row>

            <row>
              <entry><methodname>allMatches(Class&lt;T&gt;,
              String)</methodname></entry>

              <entry>All persisted instances with the specified string as
              their title</entry>
            </row>

            <row>
              <entry><methodname>allMatches(Class&lt;T&gt;,
              Object)</methodname></entry>

              <entry>All persisted instances matching object
              (query-by-example)</entry>
            </row>

            <row>
              <entry><methodname>allMatches(Query&lt;T&gt;)</methodname></entry>

              <entry>All instances satisfying the provided query</entry>
            </row>

            <row>
              <entry><methodname>firstMatch(...)</methodname></entry>

              <entry>As for <methodname>allMatches(...)</methodname>, but
              returning first instance</entry>
            </row>

            <row>
              <entry><methodname>uniqueMatch(...)</methodname></entry>

              <entry>As for <methodname>firstMatch(...)</methodname>, but
              requiring there to be only one match</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table>
        <title>DomainObjectContainer methods (2 of 2)</title>

        <tgroup cols="3">
          <colspec align="center" colwidth="70" />

          <colspec align="left" colwidth="180" />

          <colspec align="left" />

          <thead>
            <row>
              <entry align="center">Category</entry>

              <entry align="center">Method</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry morerows="4">Object persistence</entry>

              <entry><methodname>isPersistent(Object)</methodname></entry>

              <entry>whether object is persistent</entry>
            </row>

            <row>
              <entry><methodname>persist(Object)</methodname></entry>

              <entry>persist the transient object</entry>
            </row>

            <row>
              <entry><methodname>persistIfNotAlready(Object)</methodname></entry>

              <entry>persist the object (provided is not already
              persisted)</entry>
            </row>

            <row>
              <entry><methodname>remove(Object)</methodname></entry>

              <entry>remove the persisted object</entry>
            </row>

            <row>
              <entry><methodname>removeIfNotAlready(Object)</methodname></entry>

              <entry>remove the object (provided is not already
              transient)</entry>
            </row>

            <row>
              <entry>Presentation</entry>

              <entry><methodname>titleOf(Object)</methodname></entry>

              <entry>Returns the title of the object.</entry>
            </row>

            <row>
              <entry morerows="2">Messages and warnings</entry>

              <entry><methodname>informUser(String)</methodname></entry>

              <entry>Inform the user</entry>
            </row>

            <row>
              <entry><methodname>warnUser(String)</methodname></entry>

              <entry>Warn the user about a situation, requiring
              acknowledgement.</entry>
            </row>

            <row>
              <entry><methodname>raiseError(String)</methodname></entry>

              <entry>Notify user of a serious application error, typically
              requiring further action on behalf of the user</entry>
            </row>

            <row>
              <entry>Security</entry>

              <entry><methodname>getUser()</methodname></entry>

              <entry>The currently-logged on user</entry>
            </row>

            <row>
              <entry morerows="1">Properties</entry>

              <entry><methodname>getProperty(String)</methodname></entry>

              <entry>Value of configuration property</entry>
            </row>

            <row>
              <entry><methodname>getPropertyNames()</methodname></entry>

              <entry>All configuration properties available</entry>
            </row>

            <row>
              <entry morerows="1">Lazy loading, dirty object tracking
              (*)</entry>

              <entry><methodname>resolve(Object)</methodname></entry>

              <entry>Lazy load object (overloaded to optionally load a
              property of object)</entry>
            </row>

            <row>
              <entry><methodname>objectChanged(Object)</methodname></entry>

              <entry>Mark object as dirty</entry>
            </row>

            <row>
              <entry morerows="1">Object store control (**)</entry>

              <entry><methodname>flush()</methodname></entry>

              <entry>Flush all pending changes to object store</entry>
            </row>

            <row>
              <entry><methodname>commit()</methodname></entry>

              <entry>Commit all pending changes to object store</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para><note>
          <para>(*) generally not necessary to call - performed by bytecode
          proxies</para>
        </note><note>
          <para>(**) the use of these methods is discouraged - they are
          typically used only for tests</para>
        </note></para>
    </appendix>

    <appendix id="apx.SecurityClasses">
      <title>Security Classes</title>

      <abstract>
        <para>A simple set of classes to represent the currently logged on
        user and their roles.</para>
      </abstract>

      <para>When the user logs onto an Isis application, the framework
      constructs a representation of their user and roles using classes from
      the applib. This allows the application to inspect and act upon those
      details if required.</para>

      <para>The user details are captured in the
      <classname>org.apache.isis.applib.security.UserMemento</classname> class
      ("memento" because it is a snapshot of their credentials at the point of
      logging on). The <classname>UserMemento</classname> class defines the
      following properties:</para>

      <itemizedlist>
        <listitem>
          <para><varname>name</varname> (a
          <classname>String</classname>)</para>
        </listitem>

        <listitem>
          <para>collection of roles (as
          <classname>RoleMemento</classname>)</para>
        </listitem>
      </itemizedlist>

      <para>The org.apache.isis.applib.security.RoleMemento class in turn
      defines two properties:</para>

      <itemizedlist>
        <listitem>
          <para><varname>name</varname> (a
          <classname>String</classname>)</para>
        </listitem>

        <listitem>
          <para><varname>description</varname> (a
          <classname>String</classname>)</para>
        </listitem>
      </itemizedlist>

      <para>To obtain the current user, the application can call
      <methodname>DomainObjectContainer#getUser()</methodname>. For more on
      the <classname>DomainObjectContainer</classname>, see <xref
      linkend="apx.DomainObjectContainer" />.</para>
    </appendix>

    <appendix id="apx.UtilityClasses">
      <title>Utility Classes</title>

      <abstract>
        <para>Simple utility classes for domain objects.</para>
      </abstract>

      <para>The <package>org.apache.isis.applib.util</package> package has a
      number of simple utility classes designed to simplify the coding of some
      common tasks.</para>

      <sect1>
        <title>Title creation</title>

        <para>The <classname>TitleBuffer</classname> utility class is intended
        to make it easy to construct title strings (returned from the
        <methodname>title()</methodname> method). For example, it has
        overloaded versions of methods called
        <methodname>append()</methodname> and
        <methodname>concat()</methodname>.</para>
      </sect1>

      <sect1>
        <title>Reason text creation (for disable and validate methods)</title>

        <para>There are two different classes provided to help build reasons
        returned by <methodname>disableXxX()</methodname> and
        <methodname>validateXxx()</methodname> methods:</para>

        <itemizedlist>
          <listitem>
            <para>the
            <classname>org.apache.isis.applib.util.ReasonBuffer</classname>
            helper class</para>
          </listitem>

          <listitem>
            <para>the
            <classname>org.apache.isis.applib.util.Reasons</classname> helper
            class</para>
          </listitem>
        </itemizedlist>

        <para>For example:</para>

        <programlisting>public class Customer {
    ...
    public String validatePlaceOrder(Product p, int quantity) {
        return Reasons.coalesce(
            whetherCustomerBlacklisted(this),
            whetherProductOutOfStock(p)
        );
    }
}</programlisting>

        <para>Which you use (if any) is up to you.</para>
      </sect1>
    </appendix>

    <appendix>
      <title>Events</title>

      <abstract>
        <para>The <classname>InteractionEvent</classname> hierarchy.</para>
      </abstract>

      <para>Although not supported by the default programming model, the
      applib nevertheless defines an event hierarchy that characterizes all of
      the different types of interactions that can occur. This is used by the
      wrapper programming model, and is exploited by the JUnit viewer.</para>

      <para>The following <acronym>UML</acronym> class diagram shows the
      hierarchy of events:</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/Events.png" scale="30" />
        </imageobject>
      </mediaobject>
    </appendix>

    <appendix>
      <title>Package Dependencies</title>

      <abstract>
        <para>The dependencies between the packages.</para>
      </abstract>

      <para>*** these diagrams are out of date ***</para>

      <para>The following diagram shows that the relationship between the
      different packages that make up the applib (note that there are no
      cyclic dependencies between the packages):</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/composition-perspective.png" scale="70" />
        </imageobject>
      </mediaobject>

      <para>The following diagram shows the same packages, but from a layered,
      architecture perspective:</para>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/architecture-perspective.png" scale="70" />
        </imageobject>
      </mediaobject>
    </appendix>
  </part>
</book>